<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Leaflet Map Marker & Rectangle Editor</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    #map { height: 100vh; width: 100vw; }
    .mode-toggle { position: fixed; top: 10px; left: 10px; z-index: 1000; }
    .rotate-handle {
      background: #3388ff;
      border-radius: 50%;
      width: 14px;
      height: 14px;
      box-shadow: 0 0 2px #222;
      border: none;
    }
  </style>
</head>
<body>
<button class="mode-toggle">Switch to Edit Mode</button>
<div id="map"></div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
let editMode = false;
const modeToggle = document.querySelector('.mode-toggle');
const map = L.map('map').setView([51.898819375615844, 5.7732504428013165], 18);

L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; OpenStreetMap &copy; CARTO',
  subdomains: 'abcd',
  minZoom: 16,
  maxZoom: 22
}).addTo(map);

L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles &copy; Esri'
}).addTo(map);

let markerData = [];
let mapObjects = [];

// Rectangle math from your original code:
function metersToLatLng(centerLatLng, dx, dy) {
  var R = 6378137;
  var dLat = dy / R;
  var dLng = dx / (R * Math.cos(Math.PI * centerLatLng.lat / 180));
  return [
    centerLatLng.lat + dLat * 180 / Math.PI,
    centerLatLng.lng + dLng * 180 / Math.PI
  ];
}
function getRectangleCornersMeters(centerLatLng, width_m, height_m, angleDeg) {
  var hw = width_m / 2;
  var hh = height_m / 2;
  var angleRad = angleDeg * Math.PI / 180;
  var localCorners = [
    [-hw, -hh], // SW
    [ hw, -hh], // SE
    [ hw,  hh], // NE
    [-hw,  hh]  // NW
  ];
  return localCorners.map(function(p) {
    var x = p[0], y = p[1];
    var xr = x * Math.cos(angleRad) - y * Math.sin(angleRad);
    var yr = x * Math.sin(angleRad) + y * Math.cos(angleRad);
    return metersToLatLng(centerLatLng, xr, yr);
  });
}

// Load markers & rectangles from backend
async function loadMarkers() {
  const res = await fetch('/markers.json');
  if (res.ok) {
    markerData = await res.json();
    addObjectsToMap();
  }
}

function addObjectsToMap() {
  // Remove previous objects
  mapObjects.forEach(obj => map.removeLayer(obj));
  mapObjects = [];

  markerData.forEach(data => {
    if (data.type === 'marker') {
      const marker = L.marker([data.lat, data.lng], { draggable: false })
        .addTo(map)
        .bindPopup(data.popup || '');
      mapObjects.push(marker);
    }
    if (data.type === 'rectangle') {
      addRectangle(data, false);
    }
  });
}

// Rectangle logic: add to map, optionally editable
function addRectangle(rectData, editable=true) {
  let { center, width, height, angle, popup } = rectData;
  let centerLatLng = L.latLng(center[0], center[1]);
  let corners = getRectangleCornersMeters(centerLatLng, width, height, angle);
  let rect = L.polygon(corners, { color: "blue", weight: 2 }).addTo(map);
  if (popup) rect.bindPopup(popup);

  let centerMarker, handleMarker;
  if (editable && editMode) {
    centerMarker = L.marker(centerLatLng, { draggable: true }).addTo(map);
    handleMarker = L.marker(corners[2], {
      draggable: true,
      icon: L.divIcon({ className: 'rotate-handle', iconSize: [14, 14] })
    }).addTo(map);

    // Center drag: move rectangle
    centerMarker.on('drag', function(e) {
      centerLatLng = e.latlng;
      rectData.center = [centerLatLng.lat, centerLatLng.lng];
      corners = getRectangleCornersMeters(centerLatLng, width, height, angle);
      rect.setLatLngs(corners);
      handleMarker.setLatLng(corners[2]);
      autoSaveMarkers();
    });

    // Handle drag: rotate rectangle
    handleMarker.on('drag', function(e) {
      const handleLatLng = e.latlng;
      const dx = (handleLatLng.lng - centerLatLng.lng) * Math.cos(centerLatLng.lat * Math.PI / 180) * 6378137 * Math.PI / 180;
      const dy = (handleLatLng.lat - centerLatLng.lat) * 6378137 * Math.PI / 180;
      const newAngle = Math.atan2(dy, dx) * 180 / Math.PI - 45;
      angle = newAngle;
      rectData.angle = angle;
      corners = getRectangleCornersMeters(centerLatLng, width, height, angle);
      rect.setLatLngs(corners);
      handleMarker.setLatLng(corners[2]);
      autoSaveMarkers();
    });

    // Popup for rectangle info
    centerMarker.on('click', function(e) {
      centerMarker.bindPopup('<textarea placeholder="Enter info">'+(rectData.popup||'')+'</textarea><br><button class="save-popup">Save</button>').openPopup();
      setTimeout(()=>{
        document.querySelector('.save-popup').onclick = function() {
          const info = document.querySelector('textarea').value;
          rectData.popup = info;
          rect.bindPopup(info);
          centerMarker.closePopup();
          autoSaveMarkers();
        };
      }, 150);
    });

    mapObjects.push(rect, centerMarker, handleMarker);
  } else {
    mapObjects.push(rect);
  }
}

// Add marker/rectangle on click (edit mode only)
map.on('click', function(e) {
  if (!editMode) return;

  // Simple prompt for marker or rectangle
  const type = window.prompt("Type 'marker' or 'rect' to add");
  if (type === 'marker') {
    const marker = L.marker(e.latlng, { draggable: true }).addTo(map);
    marker.bindPopup('<textarea placeholder="Enter info"></textarea><br><button class="save-popup">Save</button>').openPopup();
    marker.on('popupopen', function() {
      document.querySelector('.save-popup').onclick = function() {
        const info = document.querySelector('textarea').value;
        markerData.push({ type: 'marker', lat: marker.getLatLng().lat, lng: marker.getLatLng().lng, popup: info });
        marker.closePopup();
        autoSaveMarkers();
        addObjectsToMap();
      };
    });
    marker.on('dragend', function() {
      let m = markerData.find(m => m.lat === marker.getLatLng().lat && m.lng === marker.getLatLng().lng);
      if (m) {
        m.lat = marker.getLatLng().lat;
        m.lng = marker.getLatLng().lng;
        autoSaveMarkers();
      }
    });
  } else if (type === 'rect') {
    // Prompt user for dimensions
    let width = parseFloat(window.prompt("Rectangle width (meters)", "6")) || 6;
    let height = parseFloat(window.prompt("Rectangle height (meters)", "6")) || 6;
    let rectData = {
      type: 'rectangle',
      center: [e.latlng.lat, e.latlng.lng],
      width,
      height,
      angle: 0,
      popup: ""
    };
    markerData.push(rectData);
    addRectangle(rectData, true);
    autoSaveMarkers();
  }
});

// Toggle mode
modeToggle.onclick = function() {
  editMode = !editMode;
  modeToggle.textContent = editMode ? "Switch to Read-Only Mode" : "Switch to Edit Mode";
  addObjectsToMap();
};

function autoSaveMarkers() {
  fetch('/save-markers', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(markerData)
  });
}

// Initial load
loadMarkers();
</script>
</body>
</html>
