<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-search/dist/leaflet-search.min.css"/>
  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; }
    #map { height: 100vh; width: 100vw; position: relative; z-index: 1; }
    /* Modal styling for backups UI */
    .modal { position: fixed; z-index: 9999; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); display:flex;align-items:center;justify-content:center; }
    .modal-content { background: white; padding: 16px; border-radius: 8px; width: 520px; max-width: 95%; box-shadow: 0 6px 24px rgba(0,0,0,0.2); }
    .modal-close { cursor:pointer; float:right; font-size:20px }
    /* Simple fix to keep buttons visible */
    #editModeToggle { position: fixed; top: 10px; left: 10px; z-index: 1000; background: rgba(255,255,255,0.9); padding: 8px; border-radius: 6px; }
  </style>
</head>
<body>

  <div id="editModeToggle">
    <button id="editModeToggleBtn" style="font-weight:bold;padding:6px 18px;background:#1976d2;color:white;border:none;border-radius:6px;cursor:pointer;">
      Edit Mode
    </button>
  <button id="saveMarkersBtn" style="margin-left:16px;">Save</button>
  <button id="backupsBtn" style="margin-left:8px;">Backups</button>
    <span id="saveStatus" style="margin-left:8px;color:green;"></span>
  </div>
  <!-- Backups modal (hidden by default). Will be populated by JS when user opens Backups. -->
  <div id="backupsModal" class="modal" style="display:none;">
    <div class="modal-content">
      <span id="backupsClose" class="modal-close">&times;</span>
      <h3>Available backups (newest first)</h3>
      <div id="backupsListContainer" style="max-height:320px;overflow:auto;margin-bottom:12px;">
        <ul id="backupsList" style="list-style:none;padding:0;margin:0"></ul>
      </div>
      <div id="backupsActions" style="display:flex;gap:8px;align-items:center;">
        <button id="restoreSelectedBtn" disabled>Restore selected</button>
        <button id="cancelRestoreBtn">Cancel</button>
        <span id="backupsStatus" style="margin-left:8px;color:green"></span>
      </div>
    </div>
  </div>
  <div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-search/dist/leaflet-search.min.js"></script>
<script>
// Map initialization
// Inputs: HTML element with id 'map'
// Outputs: global `map` Leaflet map instance used throughout the file
// Side-effects: sets initial view and zoom limits to match the event grounds; other code reads `map` to add layers/markers
// Rationale: keep a single shared Leaflet instance so markers, rectangles and controls operate on the same map object.
var map = L.map('map', {
  minZoom: 16,
  maxZoom: 22
}).setView([51.898819375615844, 5.7732504428013165], 18);

// Basemap layers (tile layers)
// Purpose: provide two complementary basemaps: a neutral raster map and an imagery layer. Both are added so maintainers can
// easily switch or overlay them for debugging. We currently add both to ensure consistent visual context.
// Inputs: tile URL template and metadata (attribution, zoom limits)
// Outputs: two L.TileLayer objects attached to `map`
// Side-effects: these layers affect performance/network usage; choose low-resolution or cached tiles for production if needed.
var terrainMap = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
  subdomains: 'abcd',
  minZoom: 16,
  maxZoom: 22
});
var esri_WorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
});
terrainMap.addTo(map);
esri_WorldImagery.addTo(map);


// --- Edit mode logic ---
// Purpose: track whether the UI is in editor mode (allow moving markers, rotating rectangles and showing save buttons)
// Data model: `editMode` is a boolean persisted in localStorage so page reloads keep the selected mode.
// Inputs: user clicking the toggle button
// Outputs/Side-effects: toggles visibility of the save button, stores new mode in localStorage, and reloads the page
// Rationale: we reload the page on mode change to force Leaflet to rebuild popups and drawing layers consistently. This
// avoids subtle state bugs where popup content or input `disabled` attributes are stale after switching modes.
var editMode = localStorage.getItem('editMode') === 'true';
var editModeToggleBtn = document.getElementById('editModeToggleBtn');
var saveMarkersBtn = document.getElementById('saveMarkersBtn');
function updateSaveButtonVisibility() {
  // Show the global save button only in edit mode because saving should only be possible when editing.
  saveMarkersBtn.style.display = editMode ? '' : 'none';
}
updateSaveButtonVisibility();
editModeToggleBtn.textContent = editMode ? 'Switch to read-only' : 'Switch to edit-mode';
editModeToggleBtn.addEventListener('click', function() {
  // Toggle edit mode, persist choice and reload to ensure UI/popup consistency.
  editMode = !editMode;
  localStorage.setItem('editMode', editMode);
  editModeToggleBtn.textContent = editMode ? 'Switch to read-only' : 'Switch to edit-mode';
  updateSaveButtonVisibility();
  // Reload: forces popups and Leaflet handlers to be reconstructed according to the new mode.
  location.reload();
});

// In-memory marker registry
// `markersList` holds objects representing each marker and its associated rectangle and rotate-handle.
// Each entry shape: { id, marker: L.Marker, rect: L.Polygon, handle: L.Marker, name, img, standnr, websitelink, width, height, angle }
// `nextMarkerId` is used only when creating new markers client-side to provide a temporary unique id until saved.
var markersList = [];
var nextMarkerId = 1;

// Create a layer group to hold all markers for the search control
var searchableMarkers = L.layerGroup().addTo(map);

// Load markers from `markers.json` and recreate the visual elements for each marker.
// Inputs: `markers.json` file on the same server — an array of marker objects (id, lat, lng, name, img, standnr, websitelink, angle)
// Outputs: for each JSON entry we create a Leaflet marker, a rectangle polygon (width x height), and a rotate handle marker.
// Side-effects: these objects are added to `markersList` so other UI actions (drag/rotate/save) can reference them.
// Notes: rectangles are by default added to the map; previously we used conditional display logic — keep this behaviour consistent
// with the rest of the app when toggling modes.
fetch('markers.json')
  .then(res => res.json())
  .then(data => {
    data.forEach(function(m) {
      // rectangle size and initial angle come from JSON or defaults
      var width = 6, height = 6, angle = typeof m.angle === 'number' ? m.angle : 0;
      var center = L.latLng(m.lat, m.lng);
      var corners = getRectangleCornersMeters(center, width, height, angle);
      // Create the rectangle polygon that represents the footprint of the marker (in meters)
      var rect = L.polygon(corners, {color: "blue", weight: 2});
      // Create a small draggable handle used to visually rotate the rectangle. We use L.divIcon so we can fully control appearance.
      var handle = L.marker(corners[2], {
        draggable: true,
        icon: L.divIcon({
          className: 'rotate-handle',
          iconSize: [8, 8],
          html: `<div style=\\"width:8px;height:8px;border-radius:50%;background:#3388ff;\\"></div>`
        })
      });
      // Always add the marker itself to the map so markers remain visible even in read-only mode. The rect/handle provide editing affordances.
      var marker = L.marker(center, {draggable: true, title: m.name || m.standnr || 'Unnamed'}).addTo(map);
      // Add marker to searchable layer for search control
      searchableMarkers.addLayer(marker);
      // Add rectangle and handle to the map so they are visible; earlier versions hid them in read-only which created confusion.
      rect.addTo(map);
      handle.addTo(map);
      // Store the full marker object in our in-memory registry for later updates/saves
      var markerObj = {
        id: m.id,
        marker: marker,
        rect: rect,
        handle: handle,
        name: m.name || "",
        img: m.img || "",
        standnr: m.standnr || "",
        websitelink: m.websitelink || "",
        width: width,
        height: height,
        angle: angle
      };
      marker.bindPopup(createEditablePopup(markerObj));

      marker.on('popupopen', function(ev) {
        var id = markerObj.id;
        if (editMode && document.getElementById(`save_${id}`)) {
          document.getElementById(`save_${id}`).onclick = function() {
            markerObj.name = document.getElementById(`name_${id}`).value;
            markerObj.img = document.getElementById(`img_${id}`).value;
            markerObj.standnr = document.getElementById(`standnr_${id}`).value;
            markerObj.websitelink = document.getElementById(`web_${id}`).value;
            // Update marker title for search
            markerObj.marker.options.title = markerObj.name || markerObj.standnr || 'Unnamed';
            // Direct opslaan na save-button click
            var data = markersList.map(function(obj) {
              return {
                id: obj.id,
                lat: obj.marker.getLatLng().lat,
                lng: obj.marker.getLatLng().lng,
                name: obj.name,
                img: obj.img,
                standnr: obj.standnr,
                websitelink: obj.websitelink,
                angle: obj.angle || 0
              };
            });
            fetch('/save-markers', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(data)
            });
            marker.closePopup();
          };
        }
      });

      marker.on('drag', function(e) {
        if (!editMode) return;
        var center = e.latlng;
        markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
        markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
      });
      marker.on('dragend', function(ev) {
        marker.setPopupContent(createEditablePopup(markerObj));
        if (editMode) {
          var data = markersList.map(function(obj) {
            return {
              id: obj.id,
              lat: obj.marker.getLatLng().lat,
              lng: obj.marker.getLatLng().lng,
              name: obj.name,
              img: obj.img,
              standnr: obj.standnr,
              websitelink: obj.websitelink,
              angle: obj.angle || 0
            };
          });
          fetch('/save-markers', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
          });
        }
      });

      handle.on('drag', function(e) {
        if (!editMode) return;
        var center = marker.getLatLng();
        var handleLatLng = e.latlng;
        var dx = (handleLatLng.lng - center.lng) * Math.cos(center.lat * Math.PI / 180) * 6378137 * Math.PI / 180;
        var dy = (handleLatLng.lat - center.lat) * 6378137 * Math.PI / 180;
        var newAngle = Math.atan2(dy, dx) * 180 / Math.PI - 45;
        markerObj.angle = newAngle;
        markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
        markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
      });
      handle.on('dragend', function(e) {
        marker.setPopupContent(createEditablePopup(markerObj));
        if (editMode) {
          var data = markersList.map(function(obj) {
            return {
              id: obj.id,
              lat: obj.marker.getLatLng().lat,
              lng: obj.marker.getLatLng().lng,
              name: obj.name,
              img: obj.img,
              standnr: obj.standnr,
              websitelink: obj.websitelink,
              angle: obj.angle || 0
            };
          });
          fetch('/save-markers', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
          });
        }
      });

      marker.on('contextmenu', function(ev) {
  if (!editMode) return;
  map.removeLayer(marker);
  map.removeLayer(rect);
  map.removeLayer(handle);
  markersList = markersList.filter(function(obj) { return obj.id !== markerObj.id; });
      });

      marker.dragging[editMode ? 'enable' : 'disable']();
      handle.dragging[editMode ? 'enable' : 'disable']();
      markersList.push(markerObj);
      if (markerObj.id >= nextMarkerId) nextMarkerId = markerObj.id + 1;
    });
    
    // ============================================================
    // ADD SEARCH CONTROL
    // ============================================================
    // The Leaflet Search plugin allows you to search
    // through a layer by a specific property (here: "title").
    // It automatically lists options as you type.
    // ============================================================
    
      // Configure the search control with auto-completion
      var searchControl = L.control.search({
        layer: searchableMarkers,
        propertyName: 'title', // Use the title property we set on markers
        initial: false,
        collapsed: true,
        textPlaceholder: 'Search booths, stands, names...',
        zoom: 20,
        moveToLocation: function(latlng, title, map) {
          // First smoothly fly to the location
          map.flyTo(latlng, 20);
          // Then find and open the popup for the found marker
          searchableMarkers.eachLayer(function(layer) {
            if (layer.getLatLng().equals(latlng)) {
              layer.openPopup();
            }
          });
          // Collapse the search control after finding the marker
          this.collapse();
        }
      });
      
      // Add the search control to the map UI (defaults to top right)
      map.addControl(searchControl);
  });

function createEditablePopup(markerObj) {
  // Build popup HTML for a marker. This function is called when binding/opening a popup.
  // Inputs: markerObj (see markersList shape above)
  // Output: HTML string inserted into Leaflet popup
  // Side-effects: none — it only returns markup. Event handlers for the save button are attached in the popupopen handler.
  var lat = markerObj.marker.getLatLng().lat.toFixed(8);
  var lng = markerObj.marker.getLatLng().lng.toFixed(8);
  var id = markerObj.id;
  var name = markerObj.name || "";
  var img = markerObj.img || "";
  var standnr = markerObj.standnr || "";
  var websitelink = markerObj.websitelink || "";
  var disabled = editMode ? "" : "disabled";
  var saveBtn = editMode ? `<button id="save_${id}" style="margin-top:6px">Opslaan</button>` : "";
  var idLatLngBlock = editMode ?
    `<div><b>ID:</b> <span>${id}</span></div>
     <div><b>Lat:</b> <span>${lat}</span></div>
     <div><b>Lng:</b> <span>${lng}</span></div>`
    : "";
  return `
    <div style="min-width:220px">
      ${idLatLngBlock}
      <div><b>Naam:</b> <input type="text" id="name_${id}" value="${name}" style="width:140px" ${disabled}/></div>
      <div><b>Afbeelding:</b> <input type="text" id="img_${id}" value="${img}" style="width:140px" placeholder="URL" ${disabled}/></div>
      <div><b>Standnr:</b> <input type="number" id="standnr_${id}" value="${standnr}" style="width:60px" ${disabled}/></div>
      <div><b>Website:</b> <input type="text" id="web_${id}" value="${websitelink}" style="width:140px" placeholder="https://..." ${disabled}/></div>
      ${saveBtn}
    </div>
  `;
}

map.on('click', function(e) {
  // Handler for clicking on the map to create a NEW marker (only active in edit mode).
  // Inputs: Leaflet click event (contains latlng)
  // Outputs: new marker, rectangle and handle added to map and registered in `markersList`
  // Side-effects: increments `nextMarkerId` for client-side unique IDs.
  if (!editMode) return;
  var width = 6, height = 6, angle = 0;
  var center = e.latlng;
  var corners = getRectangleCornersMeters(center, width, height, angle);
  var rect = L.polygon(corners, {color: "blue", weight: 2}).addTo(map);
  var marker = L.marker(center, {draggable: true, title: name || standnr || 'New Booth'}).addTo(map);
  // Add to searchable layer
  searchableMarkers.addLayer(marker);
  var handle = L.marker(corners[2], {
    draggable: true,
    icon: L.divIcon({
      className: 'rotate-handle',
      iconSize: [10, 10]
    })
  }).addTo(map);
  var markerId = nextMarkerId++;
  var markerObj = {
    id: markerId,
    marker: marker,
    rect: rect,
    handle: handle,
    name: "",
    img: "",
    standnr: "",
    websitelink: "",
    width: width,
    height: height,
    angle: angle
  };
  marker.bindPopup(createEditablePopup(markerObj));

  marker.on('popupopen', function(ev) {
    var id = markerObj.id;
    // Altijd popup hertekenen met actuele editMode status
    setTimeout(function() {
      marker.setPopupContent(createEditablePopup(markerObj));
      // Save-button alleen in edit mode
      if (editMode) {
        document.getElementById(`save_${id}`).onclick = function() {
          markerObj.name = document.getElementById(`name_${id}`).value;
          markerObj.img = document.getElementById(`img_${id}`).value;
          markerObj.standnr = document.getElementById(`standnr_${id}`).value;
          markerObj.websitelink = document.getElementById(`web_${id}`).value;
          // Update marker title for search
          markerObj.marker.options.title = markerObj.name || markerObj.standnr || 'Unnamed';
          // Herteken popup zodat disabled/save-knop direct klopt
          setTimeout(function() {
            marker.setPopupContent(createEditablePopup(markerObj));
            marker.openPopup();
          }, 0);
          // Direct opslaan na save-button click
          var data = markersList.map(function(obj) {
            return {
              id: obj.id,
              lat: obj.marker.getLatLng().lat,
              lng: obj.marker.getLatLng().lng,
              name: obj.name,
              img: obj.img,
              standnr: obj.standnr,
              websitelink: obj.websitelink,
              angle: obj.angle || 0
            };
          });
          fetch('/save-markers', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
          });
        };
      }
    }, 0);
  });

  marker.on('drag', function(e) {
    var center = e.latlng;
    markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
    markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
  });
  marker.on('dragend', function(ev) {
    marker.setPopupContent(createEditablePopup(markerObj));
  });

  handle.on('drag', function(e) {
    var center = marker.getLatLng();
    var handleLatLng = e.latlng;
    var dx = (handleLatLng.lng - center.lng) * Math.cos(center.lat * Math.PI / 180) * 6378137 * Math.PI / 180;
    var dy = (handleLatLng.lat - center.lat) * 6378137 * Math.PI / 180;
    var newAngle = Math.atan2(dy, dx) * 180 / Math.PI - 45;
    markerObj.angle = newAngle;
    markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
    markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
  });
  handle.on('dragend', function(e) {
    marker.setPopupContent(createEditablePopup(markerObj));
  });

  marker.on('contextmenu', function(ev) {
    if (!editMode) return;
    map.removeLayer(marker);
    map.removeLayer(rect);
    map.removeLayer(handle);
    markersList = markersList.filter(function(obj) { return obj.id !== markerId; });
  });

  marker.dragging[editMode ? 'enable' : 'disable']();
  handle.dragging[editMode ? 'enable' : 'disable']();
  markersList.push(markerObj);
});
// Helper: meters <-> lat/lng
function metersToLatLng(centerLatLng, dx, dy) {
  // Helper: converts local meter offsets (dx east, dy north) into lat/lng around a given center point.
  // Inputs: centerLatLng (Leaflet LatLng), dx (meters east), dy (meters north)
  // Output: [lat, lng] tuple suitable for Leaflet polygons/markers
  // Notes: This uses a simple equirectangular approximation suitable for small distances (a few tens of meters).
  var R = 6378137;
  var dLat = dy / R;
  var dLng = dx / (R * Math.cos(Math.PI * centerLatLng.lat / 180));
  return [
    centerLatLng.lat + dLat * 180 / Math.PI,
    centerLatLng.lng + dLng * 180 / Math.PI
  ];
}

function getRectangleCornersMeters(centerLatLng, width_m, height_m, angleDeg) {
  var hw = width_m / 2;
  var hh = height_m / 2;
  var angleRad = angleDeg * Math.PI / 180;
  var localCorners = [
    [-hw, -hh], // SW
    [ hw, -hh], // SE
    [ hw,  hh], // NE
    [-hw,  hh]  // NW
  ];
  return localCorners.map(function(p) {
    var x = p[0], y = p[1];
    var xr = x * Math.cos(angleRad) - y * Math.sin(angleRad);
    var yr = x * Math.sin(angleRad) + y * Math.cos(angleRad);
    return metersToLatLng(centerLatLng, xr, yr);
  });
}

// Opslaan knop functionaliteit
document.getElementById('saveMarkersBtn').onclick = function() {
  // Global save handler: serializes the in-memory `markersList` into a JSON array and POSTs to the server endpoint `/save-markers`.
  // Inputs: none (reads from `markersList`)
  // Outputs: network POST request; UI feedback in the `#saveStatus` element showing success or error
  // Error handling: minimal — network errors show a brief message. For production we should handle retries and optimistic UI.
  var data = markersList.map(function(obj) {
    return {
      id: obj.id,
      lat: obj.marker.getLatLng().lat,
      lng: obj.marker.getLatLng().lng,
      name: obj.name,
      img: obj.img,
      standnr: obj.standnr,
      websitelink: obj.websitelink,
      angle: obj.angle || 0
    };
  });
  fetch('/save-markers', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  })
  .then(res => res.json())
  .then(result => {
    document.getElementById('saveStatus').textContent = result.status === 'saved' ? 'Opgeslagen!' : 'Fout bij opslaan';
    setTimeout(function() { document.getElementById('saveStatus').textContent = ''; }, 2000);
  })
  .catch(err => {
    document.getElementById('saveStatus').textContent = 'Fout bij opslaan';
    setTimeout(function() { document.getElementById('saveStatus').textContent = ''; }, 2000);
  });
};

// Backups UI: list available backups and trigger server-side restore
document.getElementById('backupsBtn').addEventListener('click', async function() {
  openBackupsModal();
});

async function openBackupsModal() {
  const modal = document.getElementById('backupsModal');
  const listEl = document.getElementById('backupsList');
  const statusEl = document.getElementById('backupsStatus');
  const restoreBtn = document.getElementById('restoreSelectedBtn');
  listEl.innerHTML = '';
  statusEl.textContent = '';
  restoreBtn.disabled = true;
  modal.style.display = 'flex';
  try {
    const res = await fetch('/backups');
    const files = await res.json();
    if (!files || files.length === 0) {
      listEl.innerHTML = '<li>(no backups)</li>';
      return;
    }
    files.slice(0, 200).forEach(function(f, i) {
      const li = document.createElement('li');
      li.style.padding = '6px 0';
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'backup_choice';
      radio.value = f;
      radio.id = 'backup_choice_' + i;
      radio.addEventListener('change', function() { restoreBtn.disabled = false; });
      const label = document.createElement('label');
      label.htmlFor = radio.id;
      label.style.marginLeft = '8px';
      label.textContent = f;
      li.appendChild(radio);
      li.appendChild(label);
      listEl.appendChild(li);
    });
  } catch (err) {
    listEl.innerHTML = '<li>Error fetching backups</li>';
  }
}

document.getElementById('backupsClose').addEventListener('click', function() {
  document.getElementById('backupsModal').style.display = 'none';
});
document.getElementById('cancelRestoreBtn').addEventListener('click', function() {
  document.getElementById('backupsModal').style.display = 'none';
});
document.getElementById('restoreSelectedBtn').addEventListener('click', async function() {
  const chosen = document.querySelector('input[name="backup_choice"]:checked');
  if (!chosen) return;
  const filename = chosen.value;
  if (!confirm('Restore backup ' + filename + '? This will overwrite current markers and attempt to push to GitHub.')) return;
  const statusEl = document.getElementById('backupsStatus');
  statusEl.style.color = 'black';
  statusEl.textContent = 'Restoring...';
  try {
    const r = await fetch('/restore-backup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ filename: filename })
    });
    const json = await r.json();
    if (r.ok && json.status === 'restored') {
      statusEl.style.color = 'green';
      statusEl.textContent = 'Restore succeeded — reloading...';
      setTimeout(() => location.reload(), 800);
    } else {
      statusEl.style.color = 'red';
      statusEl.textContent = 'Restore failed: ' + (json && json.error ? json.error : JSON.stringify(json));
    }
  } catch (err) {
    statusEl.style.color = 'red';
    statusEl.textContent = 'Error: ' + err.message;
  }
});
</script>
</script>
</body>
</html>
