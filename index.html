<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-search/dist/leaflet-search.min.css"/>
  

  <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/xolonium" type="text/css"/>
  <link href="https://cdn.materialdesignicons.com/1.3.41/css/materialdesignicons.min.css" rel="stylesheet" type="text/css" />
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" integrity="sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" integrity="sha384-gfdkjb5BdAXd+lj+gudLWI+BXq4IuLW5IT+brZEZsLFm++aCMlF1V92rMkPaX4PP" crossorigin="anonymous">
	<link rel="stylesheet" href="https://cdn.rawgit.com/olton/Metro-UI-CSS/master/build/css/metro-icons.min.css">
<!-- 	Octicons (from GitHub) -->
	<link rel="stylesheet" href="https://cdn.rawgit.com/github/octicons/master/octicons/octicons.css" type="text/css">
<!-- 	Iconic Open -->
	<link rel="stylesheet" href="https://cdn.rawgit.com/iconic/open-iconic/master/font/css/open-iconic-bootstrap.css" type="text/css">
<!-- 	Mapkey Icons -->
	<link rel="stylesheet" href="https://cdn.rawgit.com/mapshakers/mapkeyicons/master/dist/MapkeyIcons.css" type="text/css">


<!-- Xolonium typeface -->
<link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/xolonium" type="text/css"/>

	<style>
	.map {
		width:600px;
		height:400px;
		margin: 0;
	}

	.leaflet-marker-icon.sans-serif {
		font-weight: bold;
		font-family: Sans Serif;
	}

	.leaflet-marker-icon.xolonium {
		font-weight: bold;
		font-family: Xolonium;
	}
	</style>
	<style>.leaflet-map-pane div { box-shadow: none; }</style>

  <style>
    body, html { margin: 0; padding: 0; overflow: hidden; }
    #map { height: 100vh; width: 100vw; position: relative; z-index: 1; }
    /* Modal styling for backups UI */
    .modal { position: fixed; z-index: 9999; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; }
    .modal-content { background: white; padding: 16px; border-radius: 8px; width: 520px; max-width: 95%; box-shadow: 0 6px 24px rgba(0,0,0,0.2); }
    .modal-close { cursor: pointer; float: right; font-size: 20px; }
    /* Control buttons repositioned to top right */
    #editModeToggle { position: fixed; top: 10px; right: 10px; z-index: 1000; background: rgba(255,255,255,0.9); padding: 4px; border-radius: 6px; display: flex; flex-direction: column; gap: 2px; align-items: center; }
    /* Style the layer control to match our buttons */
    #layerControlContainer .leaflet-control-layers { 
      min-width: 36px; 
      min-height: 36px; 
      border: 2px solid rgba(0,0,0,0.3); 
      border-radius: 4px; 
      background: #fff;
      box-shadow: none;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
    }
    #layerControlContainer .leaflet-control-layers-toggle {
      width: 20px;
      height: 20px;
      background-size: 20px 20px;
    }
    /* Legend icon display control */
    #editLegendIcon {
      display: none;
    }
    #editLegendIcon:not([style*="display: none"]) {
      display: flex !important;
    }
    /* Common button styling */
    .control-button {
      width: 36px;
      height: 36px;
      border: 2px solid rgba(0,0,0,0.3);
      border-radius: 4px;
      background-color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      background-position: center;
      background-repeat: no-repeat;
      background-size: 20px 20px;
    }
  </style>
</head>
<body>

  <button id="editModeToggleBtn" title="Toggle Edit Mode" class="control-button" style="background-image:url('icons/pencil-icon.png'); position: fixed; top: 10px; right: 10px; z-index: 1000;">
  </button>
  <button id="backupsBtn" title="View Backups" class="control-button" style="background-image:url('icons/backup-icon.png'); position: fixed; top: 50px; right: 10px; z-index: 1000;">
  </button>
  <button id="editLegendIcon" class="control-button" style="position: fixed; top: 90px; right: 10px; z-index: 1000;" title="Edit Mode Guide">
    i
  </button>
  
  <!-- Layer control positioned under legend button -->
  <div id="layerControlContainer" style="position: fixed; top: 210px; right: 10px; z-index: 1000; display:flex; align-items:center; justify-content:center;"></div>
  
  <!-- Edit mode legend content (hidden popup) -->
  <div id="editLegendContent" style="display:none; position:fixed; top:10px; right:60px; z-index:1000; background:rgba(255,255,255,0.95); padding:12px; border-radius:6px; font-size:12px; line-height:1.4; box-shadow:0 2px 8px rgba(0,0,0,0.2); min-width:250px; border:2px solid rgba(0,0,0,0.3);">
    <h4>üìù Edit Mode Guide</h4>
    <ul>
      <li>üñ±Ô∏è <strong>Right-click map:</strong> Add new marker</li>
      <li>üëÜ <strong>Drag marker:</strong> Move position</li>
      <li>üîµ <strong>Drag blue dot:</strong> Rotate rectangle</li>
      <li>‚úèÔ∏è <strong>Click marker:</strong> Edit details</li>
      <li>‚ùå <strong>Right-click marker:</strong> Delete</li>
      <li>üîç <strong>Search:</strong> Find markers</li>
    </ul>
  </div>
  <!-- Backups modal (hidden by default). Will be populated by JS when user opens Backups. -->
  <div id="backupsModal" class="modal" style="display:none;">
    <div class="modal-content">
      <span id="backupsClose" class="modal-close">&times;</span>
      <h3>Available backups (newest first)</h3>
      <div id="backupsListContainer" style="max-height:320px;overflow:auto;margin-bottom:12px;">
        <ul id="backupsList" style="list-style:none;padding:0;margin:0"></ul>
      </div>
      <div id="backupsActions" style="display:flex;gap:8px;align-items:center;">
        <button id="restoreSelectedBtn" disabled>Restore selected</button>
        <button id="cancelRestoreBtn">Cancel</button>
        <span id="backupsStatus" style="margin-left:8px;color:green"></span>
      </div>
    </div>
  </div>
  <div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="Leaflet.Icon.Glyph.js"></script>
<script src="https://unpkg.com/leaflet-search/dist/leaflet-search.min.js"></script>
<script>
// Map initialization
// Inputs: HTML element with id 'map'
// Outputs: global `map` Leaflet map instance used throughout the file
// Side-effects: sets initial view and zoom limits to match the event grounds; other code reads `map` to add layers/markers
// Rationale: keep a single shared Leaflet instance so markers, rectangles and controls operate on the same map object.
var map = L.map('map', {
  minZoom: 16,
  maxZoom: 22
}).setView([51.898819375615844, 5.7732504428013165], 18);

// Basemap layers (tile layers)
// Purpose: provide two complementary basemaps: a neutral raster map and an imagery layer. Both are added so maintainers can
// easily switch or overlay them for debugging. We currently add both to ensure consistent visual context.
// Inputs: tile URL template and metadata (attribution, zoom limits)
// Outputs: two L.TileLayer objects attached to `map`
// Side-effects: these layers affect performance/network usage; choose low-resolution or cached tiles for production if needed.
var terrainMap = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
  subdomains: 'abcd',
  minZoom: 16,
  maxZoom: 22
});
var esri_WorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
});
terrainMap.addTo(map);
esri_WorldImagery.addTo(map);

// Add layer control
var baseLayers = {
  "Terrain": terrainMap,
  "Satellite": esri_WorldImagery
};
var layerControl = L.control.layers(baseLayers).addTo(map);

// Move layer control into our custom container
setTimeout(function() {
  var layerControlElement = layerControl.getContainer();
  var container = document.getElementById('layerControlContainer');
  if (layerControlElement && container) {
    // Move the control
    container.appendChild(layerControlElement);
    // Reset positioning to fit in our container
    layerControlElement.style.position = 'static';
    layerControlElement.style.top = 'auto';
    layerControlElement.style.right = 'auto';
    layerControlElement.style.margin = '0';
  }
}, 100);


// --- Edit mode logic ---
// Purpose: track whether the UI is in editor mode (allow moving markers, rotating rectangles and showing save buttons)
// Data model: `editMode` is a boolean persisted in localStorage so page reloads keep the selected mode.
// Inputs: user clicking the toggle button
// Outputs/Side-effects: toggles visibility of the save button, stores new mode in localStorage, and reloads the page
// Rationale: we reload the page on mode change to force Leaflet to rebuild popups and drawing layers consistently. This
// avoids subtle state bugs where popup content or input `disabled` attributes are stale after switching modes.
var editMode = localStorage.getItem('editMode') === 'true';
var editModeToggleBtn = document.getElementById('editModeToggleBtn');
var backupBtn = document.getElementById('backupsBtn');

// Initialize edit elements layer visibility based on current edit mode
function updateLayerVisibility() {
  if (editMode) {
    if (!map.hasLayer(editElements)) map.addLayer(editElements);
  } else {
    if (map.hasLayer(editElements)) map.removeLayer(editElements);
  }
}
function updateSaveButtonVisibility() {
  // Toggle the edit mode button icon based on current mode
  editModeToggleBtn.style.backgroundImage = editMode ? "url('icons/read-icon.png')" : "url('icons/pencil-icon.png')";
  // Show the backup button only in edit mode
  backupBtn.style.display = editMode ? '' : 'none';
  // Show the edit legend icon only in edit mode
  var legendIcon = document.getElementById('editLegendIcon');
  if (legendIcon) {
    legendIcon.style.display = editMode ? 'flex' : 'none';
  }
  // Control layer control container visibility - only show in edit mode
  document.getElementById('layerControlContainer').style.display = editMode ? 'flex' : 'none';
  // Control ESRI layer visibility - only show in edit mode
  if (editMode) {
    if (!map.hasLayer(esri_WorldImagery)) map.addLayer(esri_WorldImagery);
  } else {
    if (map.hasLayer(esri_WorldImagery)) map.removeLayer(esri_WorldImagery);
  }
  // Update edit elements layer visibility (only if editElements exists)
  if (typeof editElements !== 'undefined') {
    updateLayerVisibility();
  }
}
updateSaveButtonVisibility();
editModeToggleBtn.addEventListener('click', function() {
  // Toggle edit mode, persist choice and reload to ensure UI/popup consistency.
  editMode = !editMode;
  localStorage.setItem('editMode', editMode);
  updateSaveButtonVisibility();
  // Reload: forces popups and Leaflet handlers to be reconstructed according to the new mode.
  location.reload();
});

// In-memory marker registry
// `markersList` holds objects representing each marker and its associated rectangle and rotate-handle.
// Each entry shape: { id, marker: L.Marker, rect: L.Polygon, handle: L.Marker, name, img, standnr, websitelink, width, height, angle }
// `nextMarkerId` is used only when creating new markers client-side to provide a temporary unique id until saved.
var markersList = [];
var nextMarkerId = 1;

// Helper function to save markers to server
function saveMarkers() {
  var data = markersList.map(function(obj) {
    return {
      id: obj.id,
      lat: obj.marker.getLatLng().lat,
      lng: obj.marker.getLatLng().lng,
      name: obj.name,
      img: obj.img,
      standnr: obj.standnr,
      websitelink: obj.websitelink,
      angle: obj.angle || 0
    };
  });
  
  // Debug: check what we're saving
  // console.log('Saving data:', data);
  // console.log('First few items:', data.slice(0, 3).map(function(item) { 
  //   return { id: item.id, name: item.name, standnr: item.standnr }; 
  // }));
  
  fetch('/save-markers', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  })
  .then(response => {
    // console.log('Save response status:', response.status);
    return response.text();
  })
  .then(text => {
    // console.log('Save response:', text);
  })
  .catch(error => {
    console.error('Save error:', error);
  });
}

// Helper function to delete a marker
function deleteMarker(marker, rect, handle, markerId) {
  if (!editMode) return;
  map.removeLayer(marker);
  map.removeLayer(rect);
  map.removeLayer(handle);
  markersList = markersList.filter(function(obj) { return obj.id !== markerId; });
  saveMarkers();
}

// Create layer groups for different types of elements
var searchableMarkers = L.layerGroup().addTo(map); // Markers - always visible
var editElements = L.layerGroup(); // Rectangles and handles - only visible in edit mode

// Function to create a custom marker icon with stand number
function createStandNumberIcon(standnr) {
  return L.divIcon({
    className: 'stand-number-marker',
    html: `<div style="
      width: 30px; 
      height: 30px; 
      border-radius: 50%; 
      background: white; 
      border: 2px solid #333; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-weight: bold; 
      font-size: 12px; 
      color: #333;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    ">${standnr || '?'}</div>`,
    iconSize: [30, 30],
    iconAnchor: [15, 15]
  });
}

// Load markers from `markers.json` and recreate the visual elements for each marker.
// Inputs: `markers.json` file on the same server ‚Äî an array of marker objects (id, lat, lng, name, img, standnr, websitelink, angle)
// Outputs: for each JSON entry we create a Leaflet marker, a rectangle polygon (width x height), and a rotate handle marker.
// Side-effects: these objects are added to `markersList` so other UI actions (drag/rotate/save) can reference them.
// Notes: rectangles are by default added to the map; previously we used conditional display logic ‚Äî keep this behaviour consistent
// with the rest of the app when toggling modes.
fetch('markers.json')
  .then(res => res.json())
  .then(data => {
    data.forEach(function(m) {
      // rectangle size and initial angle come from JSON or defaults
      var width = 6, height = 6, angle = typeof m.angle === 'number' ? m.angle : 0;
      var center = L.latLng(m.lat, m.lng);
      var corners = getRectangleCornersMeters(center, width, height, angle);
      // Create the rectangle polygon that represents the footprint of the marker (in meters)
      var rect = L.polygon(corners, {color: "blue", weight: 2});
      // Create a small draggable handle used to visually rotate the rectangle. We use L.divIcon so we can fully control appearance.
      var handle = L.marker(corners[2], {
        draggable: true,
        icon: L.divIcon({
          className: 'rotate-handle',
          iconSize: [8, 8],
          html: `<div style=\\"width:8px;height:8px;border-radius:50%;background:#3388ff;\\"></div>`
        })
      });
      // Always add the marker itself to the map so markers remain visible even in read-only mode. The rect/handle provide editing affordances.
      var marker = L.marker(center, {draggable: true, title: m.name || m.standnr || 'Unnamed',
        icon: L.icon.glyph({
          prefix: '',
          glyph: m.standnr,
          glyphColor: 'white',
          glyphSize: '12px',
          iconUrl: 'icons/glyph-marker-icon.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          className: 'xolonium glyph-marker-icon',
          glyphAnchor: [0, -6],
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          shadowSize: [41, 41],
          shadowAnchor: [-12, -41]
        })
      }).addTo(map);
      // Add marker to searchable layer for search control
      searchableMarkers.addLayer(marker);
      // Add rectangle and handle to edit elements layer (only visible in edit mode)
      editElements.addLayer(rect);
      editElements.addLayer(handle);
      // Store the full marker object in our in-memory registry for later updates/saves
      var markerObj = {
        id: m.id,
        marker: marker,
        rect: rect,
        handle: handle,
        name: m.name || "",
  img: (typeof m.img === 'string' && m.img.trim() !== "") ? m.img : "icons/4x4Vakantiebeurs.png",
        standnr: m.standnr || "",
        websitelink: m.websitelink || "",
        width: width,
        height: height,
        angle: angle
      };
      marker.bindPopup(createEditablePopup(markerObj));

      marker.on('popupopen', function(ev) {
        var id = markerObj.id;
        // Altijd popup hertekenen met actuele data
        setTimeout(function() {
          marker.setPopupContent(createEditablePopup(markerObj));
          if (editMode && document.getElementById(`save_${id}`)) {
            document.getElementById(`save_${id}`).onclick = function() {
              markerObj.name = document.getElementById(`name_${id}`).value;
              markerObj.img = document.getElementById(`img_${id}`).value;
              markerObj.standnr = document.getElementById(`standnr_${id}`).value;
              markerObj.websitelink = document.getElementById(`web_${id}`).value;
              // Update marker title for search
              markerObj.marker.options.title = markerObj.name || markerObj.standnr || 'Unnamed';
              // Update marker glyph text direct na save
              var iconOptions = markerObj.marker.options.icon.options;
              iconOptions.glyph = markerObj.standnr;
              markerObj.marker.setIcon(L.icon.glyph(iconOptions));
              // Debug: check if markerObj is updated
              // console.log('Updated markerObj:', markerObj.name, markerObj.standnr);
              // Save using the helper function (markerObj is same object reference as in markersList)
              saveMarkers();
              marker.closePopup();
            };
            
            // Cancel button handler - restore original values
            document.getElementById(`cancel_${id}`).onclick = function() {
              document.getElementById(`name_${id}`).value = markerObj.name || "";
              document.getElementById(`img_${id}`).value = markerObj.img || "";
              document.getElementById(`standnr_${id}`).value = markerObj.standnr || "";
              document.getElementById(`web_${id}`).value = markerObj.websitelink || "";
              marker.closePopup();
            };
          }
        }, 0);
      });

      marker.on('drag', function(e) {
        if (!editMode) return;
        var center = e.latlng;
        markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
        markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
      });
      marker.on('dragend', function(ev) {
        marker.setPopupContent(createEditablePopup(markerObj));
        if (editMode) {
          saveMarkers();
        }
      });

      handle.on('drag', function(e) {
        if (!editMode) return;
        var center = marker.getLatLng();
        var handleLatLng = e.latlng;
        var dx = (handleLatLng.lng - center.lng) * Math.cos(center.lat * Math.PI / 180) * 6378137 * Math.PI / 180;
        var dy = (handleLatLng.lat - center.lat) * 6378137 * Math.PI / 180;
        var newAngle = Math.atan2(dy, dx) * 180 / Math.PI - 45;
        markerObj.angle = newAngle;
        markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
        markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
      });
      handle.on('dragend', function(e) {
        marker.setPopupContent(createEditablePopup(markerObj));
        if (editMode) {
          saveMarkers();
        }
      });

      marker.on('contextmenu', function(ev) {
        deleteMarker(marker, rect, handle, markerObj.id);
      });

      marker.dragging[editMode ? 'enable' : 'disable']();
      if (handle && handle.dragging) {
        handle.dragging[editMode ? 'enable' : 'disable']();
      }
      markersList.push(markerObj);
      if (markerObj.id >= nextMarkerId) nextMarkerId = markerObj.id + 1;
      // console.log('Updated nextMarkerId to:', nextMarkerId, 'based on marker ID:', markerObj.id);
    });
    
    // ============================================================
    // ADD SEARCH CONTROL
    // ============================================================
    // The Leaflet Search plugin allows you to search
    // through a layer by a specific property (here: "title").
    // It automatically lists options as you type.
    // ============================================================
    
      // Configure the search control with auto-completion
      var searchControl = L.control.search({
        layer: searchableMarkers,
        propertyName: 'title', // Use the title property we set on markers
        initial: false,
        collapsed: true,
        textPlaceholder: 'Search booths, stands, names...',
        zoom: 20,
        moveToLocation: function(latlng, title, map) {
          // First smoothly fly to the location
          map.flyTo(latlng, 20);
          // Then find and open the popup for the found marker
          searchableMarkers.eachLayer(function(layer) {
            if (layer.getLatLng().equals(latlng)) {
              layer.openPopup();
            }
          });
          // Collapse the search control after finding the marker
          this.collapse();
        }
      });
      
      // Add the search control to the map UI (defaults to top right)
      map.addControl(searchControl);
      
      // Initialize layer visibility after all markers are loaded
      updateLayerVisibility();
      
      // Search control positioning complete - buttons positioned via CSS only
  });

function createEditablePopup(markerObj) {
  // Build popup HTML for a marker. This function is called when binding/opening a popup.
  // Inputs: markerObj (see markersList shape above)
  // Output: HTML string inserted into Leaflet popup
  // Side-effects: none ‚Äî it only returns markup. Event handlers for the save button are attached in the popupopen handler.
  var lat = markerObj.marker.getLatLng().lat.toFixed(8);
  var lng = markerObj.marker.getLatLng().lng.toFixed(8);
  var id = markerObj.id;
  var name = markerObj.name || "";
  var img = markerObj.img || "";
  var standnr = markerObj.standnr || "";
    var defaultUrl = "https://www.4x4vakantiebeurs.nl";
    var websitelink = markerObj.websitelink && markerObj.websitelink.trim() !== "" ? markerObj.websitelink.replace(/\/$/,"") : defaultUrl;
  var info = markerObj.info || "";
  var disabled = editMode ? "" : "disabled";
  var saveBtn = editMode ? `<button id="save_${id}" style="margin-top:6px; margin-right:6px">Save</button><button id="cancel_${id}" style="margin-top:6px">Cancel</button>` : "";
  var idLatLngBlock = editMode ?
    `<div><b>ID:</b> <span>${id}</span></div>
     <div><b>Lat:</b> <span>${lat}</span></div>
     <div><b>Lng:</b> <span>${lng}</span></div>`
    : "";
    var imgHtml = img ? `<div style='margin-bottom:6px;'><img src='${img}' alt='afbeelding' style='max-width:180px;max-height:120px;display:block;'/></div>` : "";
    // Bepaal label-breedte: edit mode = 'Afbeelding:', read mode = 'Website:'
    var labelWidth = editMode ? '82px' : '68px'; // 'Afbeelding:' ‚âà 82px, 'Website:' ‚âà 68px (afhankelijk van font)
      if (editMode) {
        return `
          <div style="min-width:220px">
            ${imgHtml}
            ${idLatLngBlock}
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;"><b style="min-width:${labelWidth};">Afbeelding:</b><input type="text" id="img_${id}" value="${img}" style="flex:1 1 0%;min-width:60px;max-width:100%;" placeholder="URL" ${disabled}/></div>
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;"><b style="min-width:${labelWidth};">Naam:</b><input type="text" id="name_${id}" value="${name}" style="flex:1 1 0%;min-width:60px;max-width:100%;" ${disabled}/></div>
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;"><b style="min-width:${labelWidth};">Standnr:</b><input type="number" id="standnr_${id}" value="${standnr}" style="flex:1 1 0%;min-width:40px;max-width:100%;" ${disabled}/></div>
            <div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;"><b style="min-width:${labelWidth};">Website:</b><input type="text" id="web_${id}" value="${websitelink}" style="flex:1 1 0%;min-width:60px;max-width:100%;" placeholder="https://..." ${disabled}/></div>
            <div style="display:flex;align-items:flex-start;gap:6px;margin-bottom:2px;"><b style="min-width:${labelWidth};">Info:</b><textarea id="info_${id}" style="flex:1 1 0%;min-width:60px;max-width:100%;height:60px;resize:vertical;" ${disabled}>${info}</textarea></div>
            ${saveBtn}
          </div>
        `;
      } else {
        return `
          <div style="min-width:220px">
            ${imgHtml}
            <div style="margin-bottom:2px;text-align:left;">${name}</div>
            <div style="margin-bottom:2px;text-align:left;">Booth ${standnr}</div>
            <div style="margin-bottom:2px;text-align:left;"><a href="${websitelink}" target="_blank" rel="noopener noreferrer">${websitelink}</a></div>
            <div style="margin-bottom:2px;text-align:left;white-space:pre-line;">${info}</div>
          </div>
        `;
      }
}

map.on('contextmenu', function(e) {
  // Handler for right-clicking on the map to create a NEW marker (only active in edit mode).
  // Inputs: Leaflet contextmenu event (contains latlng)
  // Outputs: new marker, rectangle and handle added to map and registered in `markersList`
  // Side-effects: increments `nextMarkerId` for client-side unique IDs.
  if (!editMode) return;
  var width = 6, height = 6, angle = 0;
  var center = e.latlng;
  var corners = getRectangleCornersMeters(center, width, height, angle);
  var rect = L.polygon(corners, {color: "blue", weight: 2});
  var marker = L.marker(center, {draggable: true, title: 'New Booth', icon: L.icon.glyph({
    prefix: '',
    glyph: '?',
    glyphColor: 'white',
    glyphSize: '12px',
    iconUrl: 'icons/glyph-marker-icon.png',
    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
    className: 'xolonium glyph-marker-icon',
    glyphAnchor: [0, -6],
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    shadowSize: [41, 41],
    shadowAnchor: [-12, -41]
  })
  }).addTo(map);
  // Add to searchable layer
  searchableMarkers.addLayer(marker);
  var handle = L.marker(corners[2], {
    draggable: true,
    icon: L.divIcon({
      className: 'rotate-handle',
      iconSize: [8, 8],
      html: `<div style="width:8px;height:8px;border-radius:50%;background:#3388ff;"></div>`
    })
  });
  // Add rectangle and handle to edit elements layer
  editElements.addLayer(rect);
  editElements.addLayer(handle);
  var markerId = nextMarkerId++;
  var markerObj = {
    id: markerId,
    marker: marker,
    rect: rect,
    handle: handle,
    name: "",
  img: "icons/4x4Vakantiebeurs.png",
    standnr: markerId.toString(),
    websitelink: "",
    width: width,
    height: height,
    angle: angle
  };
  marker.bindPopup(createEditablePopup(markerObj));

  marker.on('popupopen', function(ev) {
    var id = markerObj.id;
    // Altijd popup hertekenen met actuele editMode status
    setTimeout(function() {
      marker.setPopupContent(createEditablePopup(markerObj));
      // Save-button alleen in edit mode
      if (editMode) {
        document.getElementById(`save_${id}`).onclick = function() {
          markerObj.name = document.getElementById(`name_${id}`).value;
          markerObj.img = document.getElementById(`img_${id}`).value;
          markerObj.standnr = document.getElementById(`standnr_${id}`).value;
          markerObj.websitelink = document.getElementById(`web_${id}`).value;
          markerObj.info = document.getElementById(`info_${id}`).value;
          // Update marker title for search
          markerObj.marker.options.title = markerObj.name || markerObj.standnr || 'Unnamed';
          // Update marker glyph text direct na save
          var iconOptions = markerObj.marker.options.icon.options;
          iconOptions.glyph = markerObj.standnr;
          markerObj.marker.setIcon(L.icon.glyph(iconOptions));
          
          // Debug: check if markerObj is updated
          // console.log('Updated markerObj:', markerObj.name, markerObj.standnr);
          
          // Update popup content with new data
          marker.setPopupContent(createEditablePopup(markerObj));
          
          // Direct opslaan na save-button click
          saveMarkers();
          marker.closePopup();
        };
        
        // Cancel button handler - restore original values
        document.getElementById(`cancel_${id}`).onclick = function() {
          document.getElementById(`name_${id}`).value = markerObj.name || "";
          document.getElementById(`img_${id}`).value = markerObj.img || "";
          document.getElementById(`standnr_${id}`).value = markerObj.standnr || "";
          document.getElementById(`web_${id}`).value = markerObj.websitelink || "";
          marker.closePopup();
        };
      }
    }, 0);
  });

  marker.on('drag', function(e) {
    var center = e.latlng;
    markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
    markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
  });
  marker.on('dragend', function(ev) {
    marker.setPopupContent(createEditablePopup(markerObj));
  });

  handle.on('drag', function(e) {
    var center = marker.getLatLng();
    var handleLatLng = e.latlng;
    var dx = (handleLatLng.lng - center.lng) * Math.cos(center.lat * Math.PI / 180) * 6378137 * Math.PI / 180;
    var dy = (handleLatLng.lat - center.lat) * 6378137 * Math.PI / 180;
    var newAngle = Math.atan2(dy, dx) * 180 / Math.PI - 45;
    markerObj.angle = newAngle;
    markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
    markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
  });
  handle.on('dragend', function(e) {
    marker.setPopupContent(createEditablePopup(markerObj));
  });

  marker.on('contextmenu', function(ev) {
    deleteMarker(marker, rect, handle, markerId);
  });

  marker.dragging[editMode ? 'enable' : 'disable']();
  handle.dragging[editMode ? 'enable' : 'disable']();
  markersList.push(markerObj);
  
  // Auto-save new marker immediately
  saveMarkers();
});
// Helper: meters <-> lat/lng
function metersToLatLng(centerLatLng, dx, dy) {
  // Helper: converts local meter offsets (dx east, dy north) into lat/lng around a given center point.
  // Inputs: centerLatLng (Leaflet LatLng), dx (meters east), dy (meters north)
  // Output: [lat, lng] tuple suitable for Leaflet polygons/markers
  // Notes: This uses a simple equirectangular approximation suitable for small distances (a few tens of meters).
  var R = 6378137;
  var dLat = dy / R;
  var dLng = dx / (R * Math.cos(Math.PI * centerLatLng.lat / 180));
  return [
    centerLatLng.lat + dLat * 180 / Math.PI,
    centerLatLng.lng + dLng * 180 / Math.PI
  ];
}

function getRectangleCornersMeters(centerLatLng, width_m, height_m, angleDeg) {
  var hw = width_m / 2;
  var hh = height_m / 2;
  var angleRad = angleDeg * Math.PI / 180;
  var localCorners = [
    [-hw, -hh], // SW
    [ hw, -hh], // SE
    [ hw,  hh], // NE
    [-hw,  hh]  // NW
  ];
  return localCorners.map(function(p) {
    var x = p[0], y = p[1];
    var xr = x * Math.cos(angleRad) - y * Math.sin(angleRad);
    var yr = x * Math.sin(angleRad) + y * Math.cos(angleRad);
    return metersToLatLng(centerLatLng, xr, yr);
  });
}

// Backups UI: list available backups and trigger server-side restore
document.getElementById('backupsBtn').addEventListener('click', async function() {
  openBackupsModal();
});

async function openBackupsModal() {
  const modal = document.getElementById('backupsModal');
  const listEl = document.getElementById('backupsList');
  const statusEl = document.getElementById('backupsStatus');
  const restoreBtn = document.getElementById('restoreSelectedBtn');
  listEl.innerHTML = '';
  statusEl.textContent = '';
  restoreBtn.disabled = true;
  modal.style.display = 'flex';
  try {
    const res = await fetch('/backups');
    const files = await res.json();
    if (!files || files.length === 0) {
      listEl.innerHTML = '<li>(no backups)</li>';
      return;
    }
    files.slice(0, 200).forEach(function(f, i) {
      const li = document.createElement('li');
      li.style.padding = '6px 0';
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'backup_choice';
      radio.value = f;
      radio.id = 'backup_choice_' + i;
      radio.addEventListener('change', function() { restoreBtn.disabled = false; });
      const label = document.createElement('label');
      label.htmlFor = radio.id;
      label.style.marginLeft = '8px';
      label.textContent = f;
      li.appendChild(radio);
      li.appendChild(label);
      listEl.appendChild(li);
    });
  } catch (err) {
    listEl.innerHTML = '<li>Error fetching backups</li>';
  }
}

document.getElementById('backupsClose').addEventListener('click', function() {
  document.getElementById('backupsModal').style.display = 'none';
});
document.getElementById('cancelRestoreBtn').addEventListener('click', function() {
  document.getElementById('backupsModal').style.display = 'none';
});
document.getElementById('restoreSelectedBtn').addEventListener('click', async function() {
  const chosen = document.querySelector('input[name="backup_choice"]:checked');
  if (!chosen) return;
  const filename = chosen.value;
  if (!confirm('Restore backup ' + filename + '? This will overwrite current markers and attempt to push to GitHub.')) return;
  const statusEl = document.getElementById('backupsStatus');
  statusEl.style.color = 'black';
  statusEl.textContent = 'Restoring...';
  try {
    const r = await fetch('/restore-backup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ filename: filename })
    });
    const json = await r.json();
    if (r.ok && json.status === 'restored') {
      statusEl.style.color = 'green';
      statusEl.textContent = 'Restore succeeded ‚Äî reloading...';
      setTimeout(() => location.reload(), 800);
    } else {
      statusEl.style.color = 'red';
      statusEl.textContent = 'Restore failed: ' + (json && json.error ? json.error : JSON.stringify(json));
    }
  } catch (err) {
    statusEl.style.color = 'red';
    statusEl.textContent = 'Error: ' + err.message;
  }
});

// Edit legend icon click handler
document.getElementById('editLegendIcon').addEventListener('click', function() {
  var content = document.getElementById('editLegendContent');
  if (content.style.display === 'none' || content.style.display === '') {
    content.style.display = 'block';
  } else {
    content.style.display = 'none';
  }
});

// Undo functionality - load previous backup
</script>
</script>
</body>
</html>
