    
<!DOCTYPE html>
<html>
<head>
<!-- ExcelJS voor geavanceerde Excel export -->
<script src="https://cdn.jsdelivr.net/npm/exceljs@4.3.0/dist/exceljs.min.js"></script>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet-search/dist/leaflet-search.min.css"/>
  

  <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/xolonium" type="text/css"/>
  <link href="https://cdn.materialdesignicons.com/1.3.41/css/materialdesignicons.min.css" rel="stylesheet" type="text/css" />
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" integrity="sha512-dTfge/zgoMYpP7QbHy4gWMEGsbsdZeCXz7irItjcC3sPUFtf0kuFbDz/ixG7ArTxmDjLXDmezHubeNikyKGVyQ==" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.1/css/all.css" integrity="sha384-gfdkjb5BdAXd+lj+gudLWI+BXq4IuLW5IT+brZEZsLFm++aCMlF1V92rMkPaX4PP" crossorigin="anonymous">
	<link rel="stylesheet" href="https://cdn.rawgit.com/olton/Metro-UI-CSS/master/build/css/metro-icons.min.css">
<!-- 	Octicons (from GitHub) -->
	<link rel="stylesheet" href="https://cdn.rawgit.com/github/octicons/master/octicons/octicons.css" type="text/css">
<!-- 	Iconic Open -->
	<link rel="stylesheet" href="https://cdn.rawgit.com/iconic/open-iconic/master/font/css/open-iconic-bootstrap.css" type="text/css">
<!-- 	Mapkey Icons -->
	<link rel="stylesheet" href="https://cdn.rawgit.com/mapshakers/mapkeyicons/master/dist/MapkeyIcons.css" type="text/css">


<!-- Xolonium typeface -->
<link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/xolonium" type="text/css"/>

	<style>
	.map {
		width:600px;
		height:400px;
		margin: 0;
	}

	.leaflet-marker-icon.sans-serif {
		font-weight: bold;
		font-family: Sans Serif;
	}

	.leaflet-marker-icon.xolonium {
		font-weight: bold;
		font-family: Xolonium;
	}
	</style>
	<style>.leaflet-map-pane div { box-shadow: none; }</style>

  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    #map {
      height: 100%;
      width: 100vw;
      position: relative;
      z-index: 1;
    }
    /* Modal styling for backups UI */
    .modal { position: fixed; z-index: 9999; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.4); display: flex; align-items: center; justify-content: center; }
    .modal-content { background: white; padding: 16px; border-radius: 8px; width: 520px; max-width: 95%; box-shadow: 0 6px 24px rgba(0,0,0,0.2); }
    .modal-close { cursor: pointer; float: right; font-size: 20px; }
    /* Control buttons repositioned to top right */
    #editModeToggle { position: fixed; top: 10px; right: 10px; z-index: 1000; background: rgba(255,255,255,0.9); padding: 4px; border-radius: 6px; display: flex; flex-direction: column; gap: 2px; align-items: center; }
    /* Style the layer control to match our buttons */
    #layerControlContainer .leaflet-control-layers { 
      min-width: 36px; 
      min-height: 36px; 
      border: 2px solid rgba(0,0,0,0.3); 
      border-radius: 4px; 
      background: #fff;
      box-shadow: none;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
    }
    #layerControlContainer .leaflet-control-layers-toggle {
      width: 20px;
      height: 20px;
      background-size: 20px 20px;
    }
    /* Legend icon display control */
    #editLegendIcon {
      display: none;
    }
    #editLegendIcon:not([style*="display: none"]) {
      display: flex !important;
    }
    /* Common button styling */
    .control-button {
      width: 36px;
      height: 36px;
      border: 2px solid rgba(0,0,0,0.3);
      border-radius: 4px;
      background-color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      background-position: center;
      background-repeat: no-repeat;
      background-size: 20px 20px;
    }
  </style>
</head>
<body>

  <!-- Flexbox container voor alle control knoppen -->
  <div id="controlButtonColumn" style="position:fixed;top:10px;right:10px;z-index:1000;display:flex;flex-direction:column;align-items:center;gap:10px;background:rgba(255,255,255,0.95);box-shadow:0 2px 8px rgba(0,0,0,0.2);border-radius:8px;padding:8px;">
    <button id="editModeToggleBtn" title="Toggle Edit Mode" class="control-button">
      <span id="editModeIcon" class="mdi" style="font-size:22px;"></span>
    </button>
    <button id="backupsBtn" title="View Backups" class="control-button">
      <span class="mdi mdi-backup-restore" style="font-size:22px;"></span>
    </button>
  <button id="downloadExcelBtn" style="width:36px;height:36px;border:2px solid rgba(0,0,0,0.3);border-radius:4px;background-color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;" title="Download markers als Excel/CSV">
  <span class="mdi mdi-download" style="font-size:20px;" title="Download Markers Excel"></span>
    </button>
    <label id="uploadExcelLabel" style="width:36px;height:36px;border:2px solid rgba(0,0,0,0.3);border-radius:4px;background-color:#fff;cursor:pointer;display:flex;align-items:center;justify-content:center;" title="Upload markers Excel/CSV">
  <input id="uploadExcelInput" type="file" accept=".xlsx,.csv" style="display:none" />
  <span class="mdi mdi-upload" style="font-size:20px;" title="Upload Markers Excel or CSV file"></span>
    </label>
    <button id="editLegendIcon" class="control-button" title="Edit Mode Guide">
      <span class="mdi mdi-information-outline" style="font-size:22px;"></span>
    </button>
  <div id="layerControlContainer" style="display:flex; align-items:center; justify-content:center; margin-top:8px;"></div>
    <!-- Edit mode legend content (hidden popup) nu in container -->
  </div>
  
  <!-- Layer control positioned under legend button -->
  
  <!-- Edit mode legend content (hidden popup) -->
  <div id="editLegendContent" style="display:none; position:fixed; top:10px; right:80px; z-index:1000; background:rgba(255,255,255,0.95); padding:12px; border-radius:6px; font-size:12px; line-height:1.4; box-shadow:0 2px 8px rgba(0,0,0,0.2); min-width:250px; border:2px solid rgba(0,0,0,0.3);">
    <button id="editLegendClose" title="Close" style="position:absolute; top:6px; right:8px; border:none; background:transparent; font-size:18px; line-height:1; cursor:pointer;">&times;</button>
    <h4 style="margin-top:4px;">üìù Edit Mode Guide</h4>
    <ul>
      <li>üñ±Ô∏è <strong>Right-click map:</strong> Add new marker</li>
      <li>üëÜ <strong>Drag marker:</strong> Move position</li>
      <li>üîµ <strong>Drag blue dot:</strong> Rotate rectangle</li>
      <li>‚úèÔ∏è <strong>Click marker:</strong> Edit details</li>
      <li>‚ùå <strong>Right-click marker:</strong> Delete</li>
      <li>üîç <strong>Search:</strong> Find markers</li>
    </ul>
    </div>

  <!-- Backups modal (hidden by default). Will be populated by JS when user opens Backups. -->
  <div id="backupsModal" class="modal" style="display:none;">
    <div class="modal-content">
      <span id="backupsClose" class="modal-close">&times;</span>
      <h3>Available backups (newest first)</h3>
      <div id="backupsListContainer" style="max-height:320px;overflow:auto;margin-bottom:12px;">
        <ul id="backupsList" style="list-style:none;padding:0;margin:0"></ul>
      </div>
      <div id="backupsActions" style="display:flex;gap:8px;align-items:center;">
        <button id="restoreSelectedBtn" disabled>Restore selected</button>
        <button id="cancelRestoreBtn">Cancel</button>
        <span id="backupsStatus" style="margin-left:8px;color:green"></span>
      </div>
    </div>
  </div>
  <div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script src="Leaflet.Icon.Glyph.js"></script>
<script src="https://unpkg.com/leaflet-search/dist/leaflet-search.min.js"></script>
<script>
window.addEventListener('DOMContentLoaded', function() {
  // Upload functionaliteit: bestand inlezen en preview tonen
  var uploadInput = document.getElementById('uploadExcelInput');
  uploadInput.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    const ext = file.name.split('.').pop().toLowerCase();
    if (ext === 'xlsx') {
      const reader = new FileReader();
      reader.onload = function(evt) {
        const buffer = evt.target.result;
        const workbook = new ExcelJS.Workbook();
        workbook.xlsx.load(buffer).then(function() {
          const worksheet = workbook.worksheets[0];
          const previewData = [];
          worksheet.eachRow({ includeEmpty: false }, function(row, rowNumber) {
            previewData.push(row.values.slice(1)); // ExcelJS rows zijn 1-based
          });
          showPreviewModal(previewData, file.name);
        });
      };
      reader.readAsArrayBuffer(file);
    } else if (ext === 'csv') {
      const reader = new FileReader();
      reader.onload = function(evt) {
        const text = evt.target.result;
        const rows = text.split(/\r?\n/).map(line => line.split(','));
        showPreviewModal(rows, file.name);
      };
      reader.readAsText(file);
    } else {
      alert('Bestandstype niet ondersteund. Kies een .xlsx of .csv bestand.');
    }
    // Reset input zodat je opnieuw kunt uploaden
    e.target.value = '';
  });

  // Preview modal tonen
  function showPreviewModal(data, filename) {
    // Kolomvalidatie: controleer headers
  var expectedHeaders = ['id','standnr','name','icon','img','websitelink','info'];
    var headerOk = false;
    if (data.length > 0) {
      var actual = data[0].map(function(h){return h.replace(/\s+/g,'').toLowerCase();});
      var expected = expectedHeaders.map(function(h){return h.replace(/\s+/g,'').toLowerCase();});
      headerOk = actual.length === expected.length && actual.every(function(h,i){return h === expected[i];});
    }
    // Verwijder oude modal als die bestaat
    var old = document.getElementById('previewModal');
    if (old) old.remove();
    // Maak modal
    var modal = document.createElement('div');
    modal.id = 'previewModal';
    modal.style.position = 'fixed';
    modal.style.top = '0';
    modal.style.left = '0';
    modal.style.width = '100vw';
    modal.style.height = '100vh';
    modal.style.background = 'rgba(0,0,0,0.4)';
    modal.style.zIndex = '99999';
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';
    // Content
    var content = document.createElement('div');
    content.style.background = '#fff';
    content.style.padding = '24px';
    content.style.borderRadius = '10px';
    content.style.maxWidth = '90vw';
    content.style.maxHeight = '80vh';
    content.style.overflow = 'auto';
    content.innerHTML = '<h3>Preview: ' + filename + '</h3>';
    if (!headerOk) {
      var warn = document.createElement('div');
      warn.style.background = '#fff3cd';
      warn.style.color = '#856404';
      warn.style.border = '1px solid #ffeeba';
      warn.style.padding = '10px 16px';
      warn.style.marginBottom = '12px';
      warn.style.borderRadius = '6px';
      warn.innerHTML = '<b>Warning:</b> The column headers do not match the required format.<br>Expected: <code>' + expectedHeaders.join(', ') + '</code><br><span style="color:#b71c1c;font-weight:bold;">Import is disabled until the headers are correct.</span>';
      content.appendChild(warn);
    }
    // Tabel
    const table = document.createElement('table');
    table.style.borderCollapse = 'collapse';
    table.style.width = '100%';
    table.style.marginBottom = '16px';
    // Validatie: unieke en verplichte id's, markeer lege cellen
    var idSet = new Set();
    var duplicateIds = new Set();
    data.forEach(function(row, i) {
      var tr = document.createElement('tr');
      for (let idx = 0; idx < row.length; idx++) {
        var td = document.createElement(i === 0 ? 'th' : 'td');
        var val = row[idx] !== undefined ? row[idx] : '';
        var valStr = String(val);
        td.textContent = valStr;
        td.style.border = '1px solid #1976D2';
        td.style.padding = '6px 10px';
        td.style.background = i === 0 ? '#1976D2' : (i % 2 === 0 ? '#E3F2FD' : '#fff');
        td.style.color = i === 0 ? '#fff' : '#222';
        td.style.fontWeight = i === 0 ? 'bold' : 'normal';
        // Markeer lege cellen (behalve header)
        if (i > 0 && valStr.trim() === '') {
          td.style.background = '#ffcdd2';
          td.title = 'Required field is empty';
        }
        // Markeer duplicate id's
        if (i > 0 && idx === 0) {
          if (idSet.has(valStr)) {
            td.style.background = '#ff9800';
            td.title = 'Duplicate id';
            duplicateIds.add(valStr);
          } else if (valStr.trim() !== '') {
            idSet.add(valStr);
          }
        }
        tr.appendChild(td);
      }
      table.appendChild(tr);
    });
    content.appendChild(table);
    // Buttons
    const btnRow = document.createElement('div');
    btnRow.style.display = 'flex';
    btnRow.style.justifyContent = 'flex-end';
    btnRow.style.gap = '12px';
    // Sluiten
    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Sluiten';
    closeBtn.style.padding = '8px 18px';
    closeBtn.style.background = '#eee';
    closeBtn.style.border = '1px solid #bbb';
    closeBtn.style.borderRadius = '6px';
    closeBtn.onclick = () => modal.remove();
    btnRow.appendChild(closeBtn);
    // Importeren
    var importBtn = document.createElement('button');
    importBtn.textContent = 'Importeren';
    importBtn.style.padding = '8px 18px';
    importBtn.style.background = '#1976D2';
    importBtn.style.color = '#fff';
    importBtn.style.border = 'none';
    importBtn.style.borderRadius = '6px';
    importBtn.style.fontWeight = 'bold';
    // Import-knop alleen actief als headers kloppen √©n alle id's uniek en niet leeg zijn
    var allIds = [];
    for (var i = 1; i < data.length; i++) {
      var idVal = String(data[i][0] !== undefined ? data[i][0] : '').trim();
      if (idVal !== '') allIds.push(idVal);
    }
    var uniqueIds = new Set(allIds);
    var allIdsValid = (allIds.length === uniqueIds.size) && (allIds.length === data.length-1);
    importBtn.disabled = !(headerOk && allIdsValid);
    importBtn.onclick = async function() {
      // Fetch existing markers from markers.json
      let response = await fetch('markers.json');
      let existingMarkers = await response.json();
      // Create a map of existing markers by id
      let markerMap = {};
      existingMarkers.forEach(m => { markerMap[m.id] = m; });
      // Update only editable fields for matching ids
      let updatedMarkers = [];
      let updatedCount = 0;
      for (var i = 1; i < data.length; i++) {
        var row = data[i];
        var id = String(row[0] !== undefined ? row[0] : '').trim();
        if (id && markerMap[id]) {
          markerMap[id].standnr = String(row[1] !== undefined ? row[1] : markerMap[id].standnr).trim();
          markerMap[id].name = String(row[2] !== undefined ? row[2] : markerMap[id].name).trim();
          // Haal alleen de bestandsnaam uit de icon-waarde (Excel dropdown geeft 'Naam (bestand)')
          var iconCell = String(row[3] !== undefined ? row[3] : markerMap[id].icon || "glyph-marker-icon-blue.svg").trim();
          var iconMatch = iconCell.match(/\(([^)]+)\)/);
          markerMap[id].icon = iconMatch ? iconMatch[1] : iconCell;
          markerMap[id].img = String(row[4] !== undefined ? row[4] : markerMap[id].img).trim();
          markerMap[id].websitelink = String(row[5] !== undefined ? row[5] : markerMap[id].websitelink).trim();
          // info: altijd overschrijven, ook als leeg
          markerMap[id].info = (row[6] !== undefined) ? String(row[6]).trim() : "";
          updatedMarkers.push(markerMap[id]);
          updatedCount++;
        }
      }
      // Update markersList and backupMarkers
      markersList = existingMarkers.map(m => {
        const updated = markerMap[m.id] || m;
        // Forceer icon waarde in markersList
        if (updated.icon) m.icon = updated.icon;
        return updated;
      });
      window.backupMarkers = JSON.parse(JSON.stringify(markersList));
      // Save to server
      await new Promise(resolve => { saveMarkers(); setTimeout(resolve, 400); });
      // Check if everything is updated
      let saveCheck = true; // hier kun je eventueel een fetch check toevoegen
      let backupCheck = Array.isArray(window.backupMarkers) && window.backupMarkers.length === markersList.length;
      modal.remove();
      if (typeof refreshMarkersOnMap === 'function') refreshMarkersOnMap();
      // Show feedback popup only if all checks are true
      if (saveCheck && backupCheck) {
        var popup = document.createElement('div');
        popup.textContent = updatedCount + ' markers updated successfully!';
        popup.style.position = 'fixed';
        popup.style.top = '50%';
        popup.style.left = '50%';
        popup.style.transform = 'translate(-50%, -50%)';
        popup.style.background = '#1976D2';
        popup.style.color = '#fff';
        popup.style.padding = '18px 32px';
        popup.style.borderRadius = '10px';
        popup.style.fontSize = '1.3em';
        popup.style.zIndex = '999999';
        popup.style.boxShadow = '0 4px 24px rgba(0,0,0,0.18)';
        document.body.appendChild(popup);
        setTimeout(function(){ popup.remove(); }, 2200);
      }
    };
    btnRow.appendChild(importBtn);
    content.appendChild(btnRow);
    modal.appendChild(content);
    document.body.appendChild(modal);
  }
  // Download Excel event handler
  var excelBtn = document.getElementById('downloadExcelBtn');
  if (excelBtn) {
    excelBtn.addEventListener('click', async function() {
      await markersToExcel();
    });
  }

  // markersToExcel functie verwijderen (dummy)
  // Download-knop alleen tonen in edit mode
  function updateDownloadExcelBtnVisibility() {
    var btn = document.getElementById('downloadExcelBtn');
    if (btn) {
      btn.style.display = editMode ? 'flex' : 'none';
      console.log('Download-knop gevonden:', btn, 'Edit mode:', editMode);
    } else {
      console.warn('Download-knop niet gevonden in de DOM!');
    }
      var btn2 = document.getElementById('downloadExcelBtn2');
      if (btn2) {
        btn2.style.display = editMode ? 'flex' : 'none';
      }
  }
  updateDownloadExcelBtnVisibility();
  editModeToggleBtn.addEventListener('click', updateDownloadExcelBtnVisibility);

  // Download markers als Excel (.xlsx) met freeze panes via ExcelJS
  async function markersToExcel() {
      // Opties voor marker iconen met Engelse naam
      const iconOptions = [
        'Blue (glyph-marker-icon-blue.svg)',
        'Red (glyph-marker-icon-red.svg)',
        'Orange (glyph-marker-icon-orange.svg)',
        'Green (glyph-marker-icon-green.svg)',
        'Yellow (glyph-marker-icon-yellow.svg)',
        'Purple (glyph-marker-icon-purple.svg)',
        'Black (glyph-marker-icon-black.svg)',
        'Gray (glyph-marker-icon-gray.svg)'
      ];
    // Stijl voor header en eerste kolom
    const headerStyle = {
      font: { bold: true, color: { argb: 'FFFFFFFF' }, size: 14 },
      fill: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF1976D2' } }
    };
    const firstColStyle = {
      font: { bold: true, color: { argb: 'FFFFFFFF' }, size: 14 },
      fill: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF1976D2' } }
    };
    // Kolomheaders: id (niet aanpassen!), standnr, name, img, websitelink, info
    var header = ['id','standnr','name','icon','img','websitelink','info'];
    var rows = markersList.map(function(m) {
      return [
        m.id,
        m.standnr,
        m.name,
        m.icon || "glyph-marker-icon-blue.svg",
        m.img,
        m.websitelink,
        m.info
      ];
    });
    var workbook = new ExcelJS.Workbook();
    var worksheet = workbook.addWorksheet('Markers');
    worksheet.addRow(header);
    rows.forEach(row => worksheet.addRow(row));
    // Voeg data validatie (dropdown) toe aan de icon kolom (kolom 4)
    for (let i = 2; i <= worksheet.rowCount; i++) {
      worksheet.getRow(i).getCell(4).dataValidation = {
        type: 'list',
        allowBlank: false,
        formulae: [`"${iconOptions.join(',')}"`],
        showDropDown: true
      };
    }
    // Dynamische kolombreedte voor alle kolommen (ook gelockte), v√≥√≥r locking/protect
    for (let col = 1; col <= worksheet.columnCount; col++) {
      let maxLen = 10;
      worksheet.getColumn(col).eachCell({ includeEmpty: true }, cell => {
        let val = '';
        if (cell.value && typeof cell.value === 'object' && cell.value.richText) {
          val = cell.value.richText.map(rt => rt.text).join('');
        } else if (cell.value && Array.isArray(cell.value)) {
          val = cell.value.join(' ');
        } else {
          val = cell.value ? String(cell.value) : '';
        }
        if (val.length > maxLen) maxLen = val.length;
      });
      // Voeg extra marge toe (6 ipv 2)
      worksheet.getColumn(col).width = Math.min(Math.max(maxLen + 6, 16), 80);
    }
    // Verwijder alle kolommen na G (7)
    while (worksheet.columnCount > 7) {
      worksheet.spliceColumns(8, 1);
    }
    // Dynamische kolombreedte voor alle kolommen (ook gelockte)
    for (let col = 1; col <= worksheet.columnCount; col++) {
      let maxLen = 10;
      worksheet.getColumn(col).eachCell({ includeEmpty: true }, cell => {
        const val = cell.value ? String(cell.value) : '';
        if (val.length > maxLen) maxLen = val.length;
      });
      worksheet.getColumn(col).width = Math.min(Math.max(maxLen + 2, 12), 60);
    }
    // Stijl header (eerste rij)
    worksheet.getRow(1).eachCell(cell => {
      cell.font = headerStyle.font;
      cell.fill = headerStyle.fill;
    });
    // Stijl eerste kolom (id)
    for (let i = 2; i <= worksheet.rowCount; i++) {
      let cell = worksheet.getRow(i).getCell(1);
      cell.font = firstColStyle.font;
      cell.fill = firstColStyle.fill;
    }
    // Freeze eerste rij en eerste kolom
    worksheet.views = [ { state: 'frozen', xSplit: 1, ySplit: 1 } ];
    // Kolombreedte
    worksheet.columns = [
      {width: 7},    // id
      {width: 12},   // Booth (standnr)
      {width: 40},   // name
      {width: 24},   // icon
      {width: 60},   // img
      {width: 60},   // websitelink
      {width: 60}    // info
    ];

    // Lock alle cellen
    worksheet.eachRow({ includeEmpty: false }, function(row, rowNumber) {
      row.eachCell({ includeEmpty: false }, function(cell, colNumber) {
        cell.protection = { locked: false };
      });
    });
    // Lock eerste rij (header)
    worksheet.getRow(1).eachCell(function(cell) {
      cell.protection = { locked: true };
    });
    // Lock eerste kolom (id)
    for (let i = 2; i <= worksheet.rowCount; i++) {
      worksheet.getRow(i).getCell(1).protection = { locked: true };
    }
    // Bescherm het werkblad (zonder wachtwoord, kan aangepast worden)
    await worksheet.protect();

    // Download als xlsx
    var buffer = await workbook.xlsx.writeBuffer();
    var blob = new Blob([buffer], {type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"});
    var url = URL.createObjectURL(blob);
    var a = document.createElement('a');
    a.href = url;
    a.download = 'markers.xlsx';
    document.body.appendChild(a);
    a.click();
    setTimeout(function() { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
  }

});
// Map initialization
// Inputs: HTML element with id 'map'
// Outputs: global `map` Leaflet map instance used throughout the file
// Side-effects: sets initial view and zoom limits to match the event grounds; other code reads `map` to add layers/markers
// Rationale: keep a single shared Leaflet instance so markers, rectangles and controls operate on the same map object.
var map = L.map('map', {
  minZoom: 16,
  maxZoom: 22
}).setView([51.898819375615844, 5.7732504428013165], 18);

// Basemap layers (tile layers)
// Purpose: provide two complementary basemaps: a neutral raster map and an imagery layer. Both are added so maintainers can
// easily switch or overlay them for debugging. We currently add both to ensure consistent visual context.
// Inputs: tile URL template and metadata (attribution, zoom limits)
// Outputs: two L.TileLayer objects attached to `map`
// Side-effects: these layers affect performance/network usage; choose low-resolution or cached tiles for production if needed.
var terrainMap = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
  subdomains: 'abcd',
  minZoom: 16,
  maxZoom: 22
});
var esri_WorldImagery = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
});
terrainMap.addTo(map);
esri_WorldImagery.addTo(map);

// Add layer control
var baseLayers = {
  "Terrain": terrainMap,
  "Satellite": esri_WorldImagery
};
var layerControl = L.control.layers(baseLayers).addTo(map);

// Move layer control into our custom container
setTimeout(function() {
  var layerControlElement = layerControl.getContainer();
  var container = document.getElementById('layerControlContainer');
  if (layerControlElement && container) {
    // Move the control
    container.appendChild(layerControlElement);
    // Reset positioning to fit in our container
    layerControlElement.style.position = 'static';
    layerControlElement.style.top = 'auto';
    layerControlElement.style.right = 'auto';
    layerControlElement.style.margin = '0';
  }
}, 100);


// --- Edit mode logic ---
// Purpose: track whether the UI is in editor mode (allow moving markers, rotating rectangles and showing save buttons)
// Data model: `editMode` is a boolean persisted in localStorage so page reloads keep the selected mode.
// Inputs: user clicking the toggle button
// Outputs/Side-effects: toggles visibility of the save button, stores new mode in localStorage, and reloads the page
// Rationale: we reload the page on mode change to force Leaflet to rebuild popups and drawing layers consistently. This
// avoids subtle state bugs where popup content or input `disabled` attributes are stale after switching modes.
var editMode = localStorage.getItem('editMode') === 'true';
var editModeToggleBtn = document.getElementById('editModeToggleBtn');
var backupBtn = document.getElementById('backupsBtn');

// Initialize edit elements layer visibility based on current edit mode
function updateLayerVisibility() {
  if (editMode) {
    if (!map.hasLayer(editElements)) map.addLayer(editElements);
  } else {
    if (map.hasLayer(editElements)) map.removeLayer(editElements);
  }
}
function updateSaveButtonVisibility() {
  // Toggle the edit mode button icon based on current mode
  var iconSpan = document.getElementById('editModeIcon');
  if (iconSpan) {
    // f33f = lock-open, f33e = lock
    iconSpan.className = 'mdi ' + (editMode ? 'mdi-lock-open' : 'mdi-lock');
    iconSpan.style.fontFamily = 'Material Design Icons';
    iconSpan.style.fontSize = '22px';
  }
  // Show the backup button only in edit mode
  backupBtn.style.display = editMode ? '' : 'none';
  // Show the edit legend icon only in edit mode
  var legendIcon = document.getElementById('editLegendIcon');
  if (legendIcon) {
    legendIcon.style.display = editMode ? 'flex' : 'none';
  }
  // Control layer control container visibility - only show in edit mode
  document.getElementById('layerControlContainer').style.display = editMode ? 'flex' : 'none';
  // Control ESRI layer visibility - only show in edit mode
  if (editMode) {
    if (!map.hasLayer(esri_WorldImagery)) map.addLayer(esri_WorldImagery);
  } else {
    if (map.hasLayer(esri_WorldImagery)) map.removeLayer(esri_WorldImagery);
  }
  // Update edit elements layer visibility (only if editElements exists)
  if (typeof editElements !== 'undefined') {
    updateLayerVisibility();
  }
    // Upload-knop alleen zichtbaar in edit mode
    var uploadLabel = document.getElementById('uploadExcelLabel');
    if (uploadLabel) {
      uploadLabel.style.display = editMode ? 'flex' : 'none';
    }
}
updateSaveButtonVisibility();
editModeToggleBtn.addEventListener('click', function() {
  // Toggle edit mode, persist choice and reload to ensure UI/popup consistency.
  editMode = !editMode;
  localStorage.setItem('editMode', editMode);
  updateSaveButtonVisibility();
  // Reload: forces popups and Leaflet handlers to be reconstructed according to the new mode.
  location.reload();
});

// In-memory marker registry
// `markersList` holds objects representing each marker and its associated rectangle and rotate-handle.
// Each entry shape: { id, marker: L.Marker, rect: L.Polygon, handle: L.Marker, name, img, standnr, websitelink, width, height, angle }
// `nextMarkerId` is used only when creating new markers client-side to provide a temporary unique id until saved.
var markersList = [];
// Ververst alle markers op de kaart na import of wijziging van markersList
function refreshMarkersOnMap() {
  // Verwijder alle bestaande markers, rechthoeken en handles
  if (typeof searchableMarkers !== 'undefined') {
    searchableMarkers.clearLayers();
  }
  if (typeof editElements !== 'undefined') {
    editElements.clearLayers();
  }
  // Voeg alle markers uit markersList opnieuw toe
  markersList.forEach(function(m) {
    // Bepaal positie en eigenschappen
    var center = m.marker && m.marker.getLatLng ? m.marker.getLatLng() : (m.lat && m.lng ? L.latLng(m.lat, m.lng) : null);
    if (!center) return;
    var width = m.width || 6;
    var height = m.height || 6;
    var angle = typeof m.angle === 'number' ? m.angle : 0;
    var corners = getRectangleCornersMeters(center, width, height, angle);
    // Maak rechthoek en handle
    var rect = L.polygon(corners, {color: "blue", weight: 2});
    var handle = L.marker(corners[2], {
      draggable: true,
      icon: L.divIcon({
        className: 'rotate-handle',
        iconSize: [8, 8],
        html: `<div style=\"width:8px;height:8px;border-radius:50%;background:#3388ff;\"></div>`
      })
    });
    // Maak marker
    var marker = L.marker(center, {draggable: true, title: m.name || m.standnr || 'Unnamed',
      icon: L.icon.glyph({
        prefix: '',
        glyph: m.standnr,
        glyphColor: 'white',
        glyphSize: '12px',
        iconUrl: `icons/svg/${m.icon || 'glyph-marker-icon-blue.svg'}`,
        shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
        className: 'xolonium glyph-marker-icon',
        glyphAnchor: [0, -6],
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        shadowSize: [41, 41],
        shadowAnchor: [-12, -41]
      })
    });
    
    searchableMarkers.addLayer(marker);
    editElements.addLayer(rect);
    editElements.addLayer(handle);
    // Update markerObj in markersList
    m.marker = marker;
    m.rect = rect;
    m.handle = handle;
    marker.bindPopup(createEditablePopup(m));
  });
  updateLayerVisibility();
}
var nextMarkerId = 1;

// Helper function to save markers to server
function saveMarkers() {
  var data = markersList.map(function(obj) {
    let lat, lng;
    if (obj.marker && typeof obj.marker.getLatLng === 'function') {
      lat = obj.marker.getLatLng().lat;
      lng = obj.marker.getLatLng().lng;
    } else {
      lat = obj.lat;
      lng = obj.lng;
    }
    return {
      id: obj.id,
      lat: lat,
      lng: lng,
      name: obj.name,
      icon: obj.icon || "glyph-marker-icon-blue.svg",
      img: obj.img,
      standnr: obj.standnr,
      websitelink: obj.websitelink,
      info: obj.info || "",
      angle: obj.angle || 0
    };
  });
  
  // Debug: check what we're saving
  // console.log('Saving data:', data);
  // console.log('First few items:', data.slice(0, 3).map(function(item) { 
  //   return { id: item.id, name: item.name, standnr: item.standnr }; 
  // }));
  
  fetch('/save-markers', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  })
  .then(response => {
    // console.log('Save response status:', response.status);
    return response.text();
  })
  .then(text => {
    // console.log('Save response:', text);
  })
  .catch(error => {
    console.error('Save error:', error);
  });
}

// Helper function to delete a marker
function deleteMarker(marker, rect, handle, markerId) {
  if (!editMode) return;
  map.removeLayer(marker);
  map.removeLayer(rect);
  map.removeLayer(handle);
  markersList = markersList.filter(function(obj) { return obj.id !== markerId; });
  saveMarkers();
}

// Create layer groups for different types of elements
// --- Special Markers Section ---
// Deze markers zijn alleen zichtbaar in edit mode en worden niet ge√´xporteerd of gebackupt
var searchableMarkers = L.layerGroup().addTo(map); // Markers - always visible
var editElements = L.layerGroup(); // Rectangles and handles - only visible in edit mode

// Load markers from `markers.json` and recreate the visual elements for each marker.
// Inputs: `markers.json` file on the same server ‚Äî an array of marker objects (id, lat, lng, name, img, standnr, websitelink, angle)
// Outputs: for each JSON entry we create a Leaflet marker, a rectangle polygon (width x height), and a rotate handle marker.
// Side-effects: these objects are added to `markersList` so other UI actions (drag/rotate/save) can reference them.
// Notes: rectangles are by default added to the map; previously we used conditional display logic ‚Äî keep this behaviour consistent
// with the rest of the app when toggling modes.
fetch('markers.json')
  .then(res => res.json())
  .then(data => {
    data.forEach(function(m) {
      // rectangle size and initial angle come from JSON or defaults
      var width = 6, height = 6, angle = typeof m.angle === 'number' ? m.angle : 0;
      var center = L.latLng(m.lat, m.lng);
      var corners = getRectangleCornersMeters(center, width, height, angle);
      // Create the rectangle polygon that represents the footprint of the marker (in meters)
      var rect = L.polygon(corners, {color: "blue", weight: 2});
      // Create a small draggable handle used to visually rotate the rectangle. We use L.divIcon so we can fully control appearance.
      var handle = L.marker(corners[2], {
        draggable: true,
        icon: L.divIcon({
          className: 'rotate-handle',
          iconSize: [8, 8],
          html: `<div style=\\"width:8px;height:8px;border-radius:50%;background:#3388ff;\\"></div>`
        })
      });
      // Always add the marker itself to the map so markers remain visible even in read-only mode. The rect/handle provide editing affordances.
      var marker = L.marker(center, {draggable: true, title: m.name || m.standnr || 'Unnamed',
        icon: L.icon.glyph({
          prefix: '',
          glyph: m.standnr,
          glyphColor: 'white',
          glyphSize: '12px',
          iconUrl: `icons/svg/${m.icon || 'glyph-marker-icon-blue.svg'}`,
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          className: 'xolonium glyph-marker-icon',
          glyphAnchor: [0, -6],
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          shadowSize: [41, 41],
          shadowAnchor: [-12, -41]
        })
      }).addTo(map);
      // Add marker to searchable layer for search control
      searchableMarkers.addLayer(marker);
      // Add rectangle and handle to edit elements layer (only visible in edit mode)
      editElements.addLayer(rect);
      editElements.addLayer(handle);
      // Store the full marker object in our in-memory registry for later updates/saves
      var markerObj = {
    id: m.id,
    marker: marker,
    rect: rect,
    handle: handle,
    name: m.name || "",
    icon: m.icon || "glyph-marker-icon-blue.svg",
    img: (typeof m.img === 'string' && m.img.trim() !== "") ? m.img : "logos/4x4Vakantiebeurs.png",
    standnr: m.standnr || "",
    websitelink: m.websitelink || "",
    info: (typeof m.info === 'string' ? m.info : ""),
    width: width,
    height: height,
    angle: angle
      };
      marker.bindPopup(createEditablePopup(markerObj));

      marker.on('popupopen', function(ev) {
        var id = markerObj.id;
        // Altijd popup hertekenen met actuele data
        setTimeout(function() {
          marker.setPopupContent(createEditablePopup(markerObj));
          if (editMode && document.getElementById(`save_${id}`)) {
            // Live preview van marker icon bij selectie
            var iconSelect = document.getElementById(`icon_${id}`);
            var preview = document.getElementById(`iconPreview_${id}`);
            var originalIcon = markerObj.icon;
            if (iconSelect && preview) {
              iconSelect.addEventListener('change', function() {
                var file = iconSelect.value;
                preview.innerHTML = `<img src='icons/svg/${file}' style='width:28px;height:28px;'/>`;
              });
            }
            document.getElementById(`save_${id}`).onclick = function() {
              markerObj.name = document.getElementById(`name_${id}`).value;
              markerObj.img = document.getElementById(`img_${id}`).value;
              markerObj.standnr = document.getElementById(`standnr_${id}`).value;
              markerObj.websitelink = document.getElementById(`web_${id}`).value;
              markerObj.info = document.getElementById(`info_${id}`).value;
              // Marker kleur/icon
              var iconFileRaw = iconSelect.value;
              var iconFileClean = iconFileRaw;
              var match = iconFileRaw.match(/\(([^)]+)\)/);
              if (match) {
                iconFileClean = match[1];
              } else if (iconFileRaw.includes(' ')) {
                iconFileClean = iconFileRaw.split(' ').pop();
              }
              markerObj.icon = iconFileClean;
              var idx = markersList.findIndex(m => m.id === markerObj.id);
              if (idx !== -1) markersList[idx].icon = iconFileClean;
              var iconOptions = markerObj.marker.options.icon.options;
              iconOptions.iconUrl = `icons/svg/${iconFileClean}`;
              markerObj.marker.options.icon.options.iconUrl = `icons/svg/${iconFileClean}`;
              iconOptions.glyph = markerObj.standnr;
              markerObj.marker.setIcon(L.icon.glyph(iconOptions));
              markerObj.marker.options.title = markerObj.name || markerObj.standnr || 'Unnamed';
              saveMarkers();
              marker.closePopup();
            };
            // Cancel button handler - restore originele preview
            document.getElementById(`cancel_${id}`).onclick = function() {
              document.getElementById(`name_${id}`).value = markerObj.name || "";
              document.getElementById(`img_${id}`).value = markerObj.img || "";
              document.getElementById(`standnr_${id}`).value = markerObj.standnr || "";
              document.getElementById(`web_${id}`).value = markerObj.websitelink || "";
              if (preview) preview.innerHTML = `<img src='icons/svg/${originalIcon}' style='width:28px;height:28px;'/>`;
              marker.closePopup();
            };
          }
        }, 0);
      });

      marker.on('drag', function(e) {
        if (!editMode) return;
        var center = e.latlng;
        markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
        markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
      });
      marker.on('dragend', function(ev) {
        marker.setPopupContent(createEditablePopup(markerObj));
        if (editMode) {
          saveMarkers();
        }
      });

      handle.on('drag', function(e) {
        if (!editMode) return;
        var center = marker.getLatLng();
        var handleLatLng = e.latlng;
        var dx = (handleLatLng.lng - center.lng) * Math.cos(center.lat * Math.PI / 180) * 6378137 * Math.PI / 180;
        var dy = (handleLatLng.lat - center.lat) * 6378137 * Math.PI / 180;
        var newAngle = Math.atan2(dy, dx) * 180 / Math.PI - 45;
        markerObj.angle = newAngle;
        markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
        markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
      });
      handle.on('dragend', function(e) {
        marker.setPopupContent(createEditablePopup(markerObj));
        if (editMode) {
          saveMarkers();
        }
      });

      marker.on('contextmenu', function(ev) {
        deleteMarker(marker, rect, handle, markerObj.id);
      });

      marker.dragging[editMode ? 'enable' : 'disable']();
      if (handle && handle.dragging) {
        handle.dragging[editMode ? 'enable' : 'disable']();
      }
      markersList.push(markerObj);
      if (markerObj.id >= nextMarkerId) nextMarkerId = markerObj.id + 1;
      // console.log('Updated nextMarkerId to:', nextMarkerId, 'based on marker ID:', markerObj.id);
    });
    
    // ============================================================
    // ADD SEARCH CONTROL
    // ============================================================
    // The Leaflet Search plugin allows you to search
    // through a layer by a specific property (here: "title").
    // It automatically lists options as you type.
    // ============================================================
    
      // Configure the search control with auto-completion
      var searchControl = L.control.search({
        layer: searchableMarkers,
        propertyName: 'title', // Use the title property we set on markers
        initial: false,
        collapsed: true,
        textPlaceholder: 'Search booths, stands, names...',
        zoom: 20,
        moveToLocation: function(latlng, title, map) {
          // First smoothly fly to the location
          map.flyTo(latlng, 20);
          // Then find and open the popup for the found marker
          searchableMarkers.eachLayer(function(layer) {
            if (layer.getLatLng().equals(latlng)) {
              layer.openPopup();
            }
          });
          // Collapse the search control after finding the marker
          this.collapse();
        }
      });
      
      // Add the search control to the map UI (defaults to top right)
      map.addControl(searchControl);
      
      // Initialize layer visibility after all markers are loaded
      updateLayerVisibility();
      
      // Search control positioning complete - buttons positioned via CSS only
  });

function createEditablePopup(markerObj) {
  // Build popup HTML for a marker. This function is called when binding/opening a popup.
  // Inputs: markerObj (see markersList shape above)
  // Output: HTML string inserted into Leaflet popup
  // Side-effects: none ‚Äî it only returns markup. Event handlers for the save button are attached in the popupopen handler.
  var lat = markerObj.marker.getLatLng().lat.toFixed(8);
  var lng = markerObj.marker.getLatLng().lng.toFixed(8);
  var id = markerObj.id;
  var name = markerObj.name || "";
  var img = markerObj.img || "";
  // Corrigeer legacy pad voor 4x4Vakantiebeurs.png
  if (img === "icons/png/4x4Vakantiebeurs.png" || img === "icons/4x4Vakantiebeurs.png") {
    img = "logos/4x4Vakantiebeurs.png";
  }
  var standnr = markerObj.standnr || "";
    var defaultUrl = "https://www.4x4vakantiebeurs.nl";
    var websitelink = markerObj.websitelink && markerObj.websitelink.trim() !== "" ? markerObj.websitelink.replace(/\/$/,"") : defaultUrl;
  var info = markerObj.info || "";
  var disabled = editMode ? "" : "disabled";
  var saveBtn = editMode ? `<button id="save_${id}" style="margin-top:6px; margin-right:6px">Save</button><button id="cancel_${id}" style="margin-top:6px">Cancel</button>` : "";
  var idLatLngBlock = editMode ?
    `<div><b>ID:</b> <span>${id}</span></div>
     <div><b>Lat:</b> <span>${lat}</span></div>
     <div><b>Lng:</b> <span>${lng}</span></div>`
    : "";
    var imgHtml = img ? `<div style='margin-bottom:6px;'><img src='${img}' alt='afbeelding' style='max-width:180px;max-height:120px;display:block;'/></div>` : "";
    // Marker icon kleur opties
    const markerIcons = [
      'glyph-marker-icon-blue.svg',
      'glyph-marker-icon-red.svg',
      'glyph-marker-icon-orange.svg',
      'glyph-marker-icon-green.svg',
      'glyph-marker-icon-yellow.svg',
      'glyph-marker-icon-purple.svg',
      'glyph-marker-icon-black.svg',
      'glyph-marker-icon-gray.svg'
    ];
    let currentFile = markerObj.icon || 'glyph-marker-icon-blue.svg';
    var labelWidth = editMode ? '82px' : '68px';
    if (editMode) {
            // Live preview van marker icon bij selectie
            var iconSelect = document.getElementById(`icon_${id}`);
            if (iconSelect) {
              iconSelect.addEventListener('change', function() {
                var file = iconSelect.value;
                var preview = document.getElementById(`iconPreview_${id}`);
                if (preview) preview.innerHTML = `<img src='icons/svg/${file}' style='width:28px;height:28px;'/>`;
              });
            }
      // Select dropdown met SVG previews
      let iconSelectHtml = `<div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;"><b style="min-width:${labelWidth};">Marker icon:</b><select id="icon_${id}" style="flex:1 1 0%;min-width:60px;max-width:100%;">`;
      markerIcons.forEach(file => {
        iconSelectHtml += `<option value="${file}"${file===currentFile?' selected':''}>${file}</option>`;
      });
      iconSelectHtml += `</select>`;
      // SVG preview
      iconSelectHtml += `<span id="iconPreview_${id}" style="display:inline-block;width:28px;height:28px;vertical-align:middle;margin-left:8px;"><img src="icons/svg/${currentFile}" style="width:28px;height:28px;"/></span></div>`;
      return `
        <div style="min-width:220px">
          ${imgHtml}
          ${idLatLngBlock}
          ${iconSelectHtml}
          <div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;"><b style="min-width:${labelWidth};">Afbeelding:</b><input type="text" id="img_${id}" value="${img}" style="flex:1 1 0%;min-width:60px;max-width:100%;" placeholder="URL" ${disabled}/></div>
          <div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;"><b style="min-width:${labelWidth};">Naam:</b><input type="text" id="name_${id}" value="${name}" style="flex:1 1 0%;min-width:60px;max-width:100%;" ${disabled}/></div>
          <div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;"><b style="min-width:${labelWidth};">Standnr:</b><input type="number" id="standnr_${id}" value="${standnr}" style="flex:1 1 0%;min-width:40px;max-width:100%;" ${disabled}/></div>
          <div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;"><b style="min-width:${labelWidth};">Website:</b><input type="text" id="web_${id}" value="${websitelink}" style="flex:1 1 0%;min-width:60px;max-width:100%;" placeholder="https://..." ${disabled}/></div>
          <div style="display:flex;align-items:flex-start;gap:6px;margin-bottom:2px;"><b style="min-width:${labelWidth};">Info:</b><textarea id="info_${id}" style="flex:1 1 0%;min-width:60px;max-width:100%;height:60px;resize:vertical;" ${disabled}>${info}</textarea></div>
          ${saveBtn}
        </div>
      `;
    } else {
        return `
          <div style="min-width:220px">
            ${imgHtml}
            <div style="margin-bottom:2px;text-align:left;">${name}</div>
            <div style="margin-bottom:2px;text-align:left;">Booth ${standnr}</div>
            <div style="margin-bottom:2px;text-align:left;"><a href="${websitelink}" target="_blank" rel="noopener noreferrer">${websitelink}</a></div>
            <div style="margin-bottom:2px;text-align:left;white-space:pre-line;">${info}</div>
          </div>
        `;
      }
}

map.on('contextmenu', function(e) {
  // Handler for right-clicking on the map to create a NEW marker (only active in edit mode).
  // Inputs: Leaflet contextmenu event (contains latlng)
  // Outputs: new marker, rectangle and handle added to map and registered in `markersList`
  // Side-effects: increments `nextMarkerId` for client-side unique IDs.
  if (!editMode) return;
  var width = 6, height = 6, angle = 0;
  var center = e.latlng;
  var corners = getRectangleCornersMeters(center, width, height, angle);
  var rect = L.polygon(corners, {color: "blue", weight: 2});
  var marker = L.marker(center, {draggable: true, title: 'New Booth', icon: L.icon.glyph({
    prefix: '',
    glyph: '?',
    glyphColor: 'white',
    glyphSize: '12px',
  iconUrl: 'icons/svg/glyph-marker-icon.svg',
    shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
    className: 'xolonium glyph-marker-icon',
    glyphAnchor: [0, -6],
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    shadowSize: [41, 41],
    shadowAnchor: [-12, -41]
  })
  }).addTo(map);
  // Add to searchable layer
  searchableMarkers.addLayer(marker);
  var handle = L.marker(corners[2], {
    draggable: true,
    icon: L.divIcon({
      className: 'rotate-handle',
      iconSize: [8, 8],
      html: `<div style="width:8px;height:8px;border-radius:50%;background:#3388ff;"></div>`
    })
  });
  // Add rectangle and handle to edit elements layer
  editElements.addLayer(rect);
  editElements.addLayer(handle);
  var markerId = nextMarkerId++;
  var markerObj = {
    id: markerId,
    marker: marker,
    rect: rect,
    handle: handle,
    name: "",
  img: "logos/4x4Vakantiebeurs.png",
    standnr: markerId.toString(),
    websitelink: "",
    info: "Ontdek de wereld van de 4x4 vakanties op de 4x4 Vakantiebeurs. De grootste beurs in de BeNeLux op het gebied van 4x4 vakanties, reizen en alles wat ermee gemoeid is.",
    width: width,
    height: height,
    angle: angle
  };
  marker.bindPopup(createEditablePopup(markerObj));

  marker.on('popupopen', function(ev) {
    var id = markerObj.id;
    // Altijd popup hertekenen met actuele editMode status
    setTimeout(function() {
      marker.setPopupContent(createEditablePopup(markerObj));
      // Save-button alleen in edit mode
      if (editMode) {
        document.getElementById(`save_${id}`).onclick = function() {
          markerObj.name = document.getElementById(`name_${id}`).value;
          markerObj.img = document.getElementById(`img_${id}`).value;
          markerObj.standnr = document.getElementById(`standnr_${id}`).value;
          markerObj.websitelink = document.getElementById(`web_${id}`).value;
          markerObj.info = document.getElementById(`info_${id}`).value;
          // Update marker title for search
          markerObj.marker.options.title = markerObj.name || markerObj.standnr || 'Unnamed';
          // Update marker glyph text direct na save
          var iconOptions = markerObj.marker.options.icon.options;
          iconOptions.glyph = markerObj.standnr;
          markerObj.marker.setIcon(L.icon.glyph(iconOptions));
          
          // Debug: check if markerObj is updated
          // console.log('Updated markerObj:', markerObj.name, markerObj.standnr);
          
          // Update popup content with new data
          marker.setPopupContent(createEditablePopup(markerObj));
          
          // Direct opslaan na save-button click
          saveMarkers();
          marker.closePopup();
        };
        
        // Cancel button handler - restore original values
        document.getElementById(`cancel_${id}`).onclick = function() {
          document.getElementById(`name_${id}`).value = markerObj.name || "";
          document.getElementById(`img_${id}`).value = markerObj.img || "";
          document.getElementById(`standnr_${id}`).value = markerObj.standnr || "";
          document.getElementById(`web_${id}`).value = markerObj.websitelink || "";
          marker.closePopup();
        };
      }
    }, 0);
  });

  marker.on('drag', function(e) {
    var center = e.latlng;
    markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
    markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
  });
  marker.on('dragend', function(ev) {
    marker.setPopupContent(createEditablePopup(markerObj));
  });

  handle.on('drag', function(e) {
    var center = marker.getLatLng();
    var handleLatLng = e.latlng;
    var dx = (handleLatLng.lng - center.lng) * Math.cos(center.lat * Math.PI / 180) * 6378137 * Math.PI / 180;
    var dy = (handleLatLng.lat - center.lat) * 6378137 * Math.PI / 180;
    var newAngle = Math.atan2(dy, dx) * 180 / Math.PI - 45;
    markerObj.angle = newAngle;
    markerObj.rect.setLatLngs(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle));
    markerObj.handle.setLatLng(getRectangleCornersMeters(center, markerObj.width, markerObj.height, markerObj.angle)[2]);
  });
  handle.on('dragend', function(e) {
    marker.setPopupContent(createEditablePopup(markerObj));
  });

  marker.on('contextmenu', function(ev) {
    deleteMarker(marker, rect, handle, markerId);
  });

  marker.dragging[editMode ? 'enable' : 'disable']();
  handle.dragging[editMode ? 'enable' : 'disable']();
  markersList.push(markerObj);
  
  // Auto-save new marker immediately
  saveMarkers();
});
// Helper: meters <-> lat/lng
function metersToLatLng(centerLatLng, dx, dy) {
  // Helper: converts local meter offsets (dx east, dy north) into lat/lng around a given center point.
  // Inputs: centerLatLng (Leaflet LatLng), dx (meters east), dy (meters north)
  // Output: [lat, lng] tuple suitable for Leaflet polygons/markers
  // Notes: This uses a simple equirectangular approximation suitable for small distances (a few tens of meters).
  var R = 6378137;
  var dLat = dy / R;
  var dLng = dx / (R * Math.cos(Math.PI * centerLatLng.lat / 180));
  return [
    centerLatLng.lat + dLat * 180 / Math.PI,
    centerLatLng.lng + dLng * 180 / Math.PI
  ];
}

function getRectangleCornersMeters(centerLatLng, width_m, height_m, angleDeg) {
  var hw = width_m / 2;
  var hh = height_m / 2;
  var angleRad = angleDeg * Math.PI / 180;
  var localCorners = [
    [-hw, -hh], // SW
    [ hw, -hh], // SE
    [ hw,  hh], // NE
    [-hw,  hh]  // NW
  ];
  return localCorners.map(function(p) {
    var x = p[0], y = p[1];
    var xr = x * Math.cos(angleRad) - y * Math.sin(angleRad);
    var yr = x * Math.sin(angleRad) + y * Math.cos(angleRad);
    return metersToLatLng(centerLatLng, xr, yr);
  });
}

// Backups UI: list available backups and trigger server-side restore
document.getElementById('backupsBtn').addEventListener('click', async function() {
  openBackupsModal();
});

async function openBackupsModal() {
  const modal = document.getElementById('backupsModal');
  const listEl = document.getElementById('backupsList');
  const statusEl = document.getElementById('backupsStatus');
  const restoreBtn = document.getElementById('restoreSelectedBtn');
  listEl.innerHTML = '';
  statusEl.textContent = '';
  restoreBtn.disabled = true;
  modal.style.display = 'flex';
  try {
  const res = await fetch('/list-backups');
    const data = await res.json();
    const backups = data.backups || [];
    if (!backups || backups.length === 0) {
      listEl.innerHTML = '<li>(no backups)</li>';
      return;
    }
    backups.slice(0, 200).forEach(function(b, i) {
      const li = document.createElement('li');
      li.style.padding = '6px 0';
      const radio = document.createElement('input');
      radio.type = 'radio';
      radio.name = 'backup_choice';
      radio.value = b.filename;
      radio.id = 'backup_choice_' + i;
      radio.addEventListener('change', function() { restoreBtn.disabled = false; });
      const label = document.createElement('label');
      label.htmlFor = radio.id;
      label.style.marginLeft = '8px';
      // Leesbare naam genereren
      let readable = b.filename;
      let comment = '';
      // Patroon: backup_YYYY-MM-DD_HH-MM.json
      const match1 = b.filename.match(/backup_(\d{4})-(\d{2})-(\d{2})_(\d{2})-(\d{2})(?:-(\d{2}))?\.json/);
      // Patroon: markers-backup-YYYYMMDDHHmmss.json en markers-backup-YYYYMMDDHHmmss..json
      const match2 = b.filename.match(/markers-backup-(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})\.json/) || b.filename.match(/markers-backup-(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})\.\.json/);
      if (match1) {
        const [_, y, m, d, h, min, s] = match1;
        readable = `${d}-${m}-${y}, ${h}:${min}${s ? ':'+s : ''}`;
        comment = 'Automatische backup';
      } else if (match2) {
        const [_, y, m, d, h, min, s] = match2;
        readable = `${d}-${m}-${y}, ${h}:${min}:${s}`;
        comment = 'Automatische backup';
      }
      label.textContent = readable;
      label.title = b.filename;
      // Marker info en diff tonen
      const infoSpan = document.createElement('span');
      let diffText = '';
      if (b.diff) {
        const d = b.diff;
        let parts = [];
        if (d.added) parts.push('+' + d.added + ' toegevoegd');
        if (d.removed) parts.push('-' + d.removed + ' verwijderd');
        // Toon altijd veld-diffs, ook als changed=0
        if ((d.changed && d.changed > 0) || (d.fields && Object.keys(d.fields).length)) {
          let fieldDetails = '';
          if (d.fields && Object.keys(d.fields).length) {
            fieldDetails = ' (' + Object.entries(d.fields).map(([k,v]) => `${k}: ${v}`).join(', ') + ')';
          }
          parts.push('~' + (d.changed || 0) + ' gewijzigd' + fieldDetails);
        }
        if (parts.length) diffText = ', diff: ' + parts.join(', ');
      }
      infoSpan.textContent = `  [${b.count} markers${diffText}]`;
      infoSpan.style.color = '#1976D2';
      infoSpan.style.fontSize = '0.95em';
      label.appendChild(infoSpan);
      if (comment) {
        const commentSpan = document.createElement('span');
        commentSpan.textContent = '  (' + comment + ')';
        commentSpan.style.color = '#888';
        commentSpan.style.fontSize = '0.95em';
        label.appendChild(commentSpan);
      }
      li.appendChild(radio);
      li.appendChild(label);
      listEl.appendChild(li);
    });
  } catch (err) {
    listEl.innerHTML = '<li>Error fetching backups</li>';
  }
}

document.getElementById('backupsClose').addEventListener('click', function() {
  document.getElementById('backupsModal').style.display = 'none';
});
document.getElementById('cancelRestoreBtn').addEventListener('click', function() {
  document.getElementById('backupsModal').style.display = 'none';
});
document.getElementById('restoreSelectedBtn').addEventListener('click', async function() {
  const chosen = document.querySelector('input[name="backup_choice"]:checked');
  if (!chosen) return;
  const filename = chosen.value;
  if (!confirm('Restore backup ' + filename + '? This will overwrite current markers and attempt to push to GitHub.')) return;
  const statusEl = document.getElementById('backupsStatus');
  statusEl.style.color = 'black';
  statusEl.textContent = 'Restoring...';
  try {
    const r = await fetch('/restore-backup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ filename: filename })
    });
    const json = await r.json();
    if (r.ok && json.status === 'restored') {
      statusEl.style.color = 'green';
      statusEl.textContent = 'Restore succeeded ‚Äî reloading...';
      setTimeout(() => location.reload(), 800);
    } else {
      statusEl.style.color = 'red';
      statusEl.textContent = 'Restore failed: ' + (json && json.error ? json.error : JSON.stringify(json));
    }
  } catch (err) {
    statusEl.style.color = 'red';
    statusEl.textContent = 'Error: ' + err.message;
  }
});

// Edit legend icon click handler
document.getElementById('editLegendIcon').addEventListener('click', function() {
  var content = document.getElementById('editLegendContent');
  if (content.style.display === 'none' || content.style.display === '') {
    content.style.display = 'block';
  } else {
    content.style.display = 'none';
  }
});

// Close button inside legend popup: only hides the popup (does not change editMode)
var legendCloseBtn = document.getElementById('editLegendClose');
if (legendCloseBtn) {
  legendCloseBtn.addEventListener('click', function(e) {
    e.stopPropagation();
    var content = document.getElementById('editLegendContent');
    if (content) content.style.display = 'none';
  });
}

// Undo functionality - load previous backup
</script>
</script>
</body>
</html>
